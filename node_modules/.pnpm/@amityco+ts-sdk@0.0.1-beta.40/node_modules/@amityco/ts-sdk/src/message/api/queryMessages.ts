import { getActiveClient } from '~/client/api';

import { fireEvent } from '~/core/events';
import { toPageRaw } from '~/core/query';
import { pullFromCache, pushToCache } from '~/cache/api';
import { ingestInCache } from '~/cache/api/ingestInCache';
import { getResolver } from '~/core/model';
import { convertQueryParams, convertResponseFromRaw } from '../utils';

/**
 * ```js
 * import { queryMessages } from '@amityco/ts-sdk'
 * const messages = await queryMessages({ channelId })
 * ```
 *
 * Queries a paginable list of {@link Amity.Message} objects
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.Message} objects
 *
 * @category Message API
 * @async
 */
export const queryMessages = async (
  query: Amity.QueryMessages,
): Promise<Amity.Cached<Amity.Paged<Amity.Message, Amity.Page<string>>>> => {
  const client = getActiveClient();
  client.log('message/queryMessages', query);

  const params = convertQueryParams(query);

  // API-FIX: parameters should be querystring. (1)
  // API-FIX: backend should answer Amity.Response (2)
  // API-FIX: pagination should not be indexed on channelSegment (3)
  // const { data } = await client.http.get<Amity.Response<Amity.Paged<Amity.MessagePayload>>>(
  const response = await client.http
    .get<Amity.MessagePayload & Amity.Pagination>(`/api/v5/messages`, { params })
    .then(convertResponseFromRaw);

  // API-FIX: backend should answer Amity.Response (2)
  // const { paging, messages } = unwrapPayload(data)
  const { paging, ...data } = response.data;
  const { messages } = data;

  const cachedAt = client.cache && Date.now();

  if (client.cache) {
    ingestInCache(data as Amity.ProcessedMessagePayload, { cachedAt });

    const cacheKey = ['message', 'query', params as Amity.Serializable];
    pushToCache(cacheKey, { messages: messages.map(getResolver('message')), paging });
  }

  fireEvent('local.message.fetched', { messages });

  const nextPage = toPageRaw(paging.next);
  const prevPage = toPageRaw(paging.previous);

  return { data: messages, cachedAt, prevPage, nextPage };
};

/**
 * ```js
 * import { queryMessages } from '@amityco/ts-sdk'
 * const messages = queryMessages.locally!({ channelId })
 * ```
 *
 * Queries a paginable list of {@link Amity.Message} objects from cache
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.Message} objects
 *
 * @category Message API
 */
queryMessages.locally = (
  query: Parameters<typeof queryMessages>[0],
): Amity.Cached<Amity.Paged<Amity.Message, Amity.Page<string>>> | undefined => {
  const client = getActiveClient();
  client.log('message/queryMessages.locally', query);

  if (!client.cache) return;

  const params = convertQueryParams(query);

  const queryKey = ['message', 'query', params as Amity.Serializable];
  const { data, cachedAt } =
    pullFromCache<{ messages: Pick<Amity.Message, 'messageId'>[] } & Amity.Pagination>(queryKey) ??
    {};

  if (!data?.messages.length) return;

  const messages: Amity.Message[] = data.messages
    .map(messageId => pullFromCache<Amity.Message>(['message', 'get', messageId])!)
    .filter(Boolean)
    .map(({ data }) => data);

  const prevPage = toPageRaw(data?.paging.previous);
  const nextPage = toPageRaw(data?.paging.next);

  return messages.length === data?.messages?.length
    ? { data: messages, cachedAt, prevPage, nextPage }
    : undefined;
};

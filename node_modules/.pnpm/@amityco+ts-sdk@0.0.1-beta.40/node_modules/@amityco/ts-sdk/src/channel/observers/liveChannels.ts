/* eslint-disable no-use-before-define */
import { getResolver } from '~/core/model';
import { pullFromCache, pushToCache } from '~/cache/api';
import { getActiveClient } from '~/client/api';
import {
  createQuery,
  runQuery,
  queryOptions,
  filterByPropEquality,
  filterByChannelMembership,
  sortByLastCreated,
  sortByDisplayName,
  sortByLastActivity,
  sortByFirstCreated,
} from '~/core/query';
import {
  COLLECTION_DEFAULT_CACHING_POLICY,
  COLLECTION_DEFAULT_PAGINATION_LIMIT,
  ENABLE_CACHE_MESSAGE,
} from '~/utils/constants';
import { onMessageCreated } from '~/message/events';
import {
  onChannelCreated,
  onChannelDeleted,
  onChannelUpdated,
  onChannelMuted,
  onChannelJoined,
  onChannelLeft,
  onChannelMemberAdded,
  onChannelMemberRemoved,
} from '../events';
import { queryChannels } from '../api';

/**
 * ```js
 * import { liveChannels } from '@amityco/ts-sdk'
 *
 * let channels = []
 * const unsub = liveChannels({
 *   displayName: Amity.Channel['displayName'],
 * }, response => merge(channels, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Channel}s
 *
 * @param params for querying channels
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the channels
 *
 * @category Channel Live Collection
 */
export const liveChannels = (
  params: Amity.ChannelLiveCollection,
  callback: Amity.LiveCollectionCallback<Amity.Channel>,
  config?: Amity.LiveCollectionConfig,
) => {
  const { log, cache, userId } = getActiveClient();

  if (!cache) {
    console.log(ENABLE_CACHE_MESSAGE);
  }

  const timestamp = Date.now();
  log(`liveChannels(tmpid: ${timestamp}) > listen`);

  const { limit: queryLimit, ...queryParams } = params;

  const limit = queryLimit ?? COLLECTION_DEFAULT_PAGINATION_LIMIT;
  const { policy = COLLECTION_DEFAULT_CACHING_POLICY } = config ?? {};

  const disposers: Amity.Unsubscriber[] = [];
  const cacheKey = ['channel', 'collection', {}];

  const responder = (data: Amity.ChannelLiveCollectionCache) => {
    let channels: Amity.Channel[] =
      data.data
        .map(channelId => pullFromCache<Amity.Channel>(['channel', 'get', channelId])!)
        .filter(Boolean)
        .map(({ data }) => data) ?? [];

    channels = filterByPropEquality(channels, 'isDeleted', params.isDeleted);
    channels = filterByPropEquality(channels, 'displayName', params.displayName);

    if (params.types) {
      channels = channels.filter(c => params.types?.includes(c.type));
    }

    if (params.tags) {
      channels = channels.filter(c => c.tags?.some(t => params.tags?.includes(t)));
    }

    if (params.excludeTags) {
      channels = channels.filter(c => !c.tags?.some(t => params.excludeTags?.includes(t)));
    }

    // userId is required to be able to filter channel by current active user
    if (params.membership && userId) {
      channels = filterByChannelMembership(channels, params.membership, userId);
    }

    switch (params.sortBy) {
      case 'firstCreated':
        channels = channels.sort(sortByFirstCreated);
        break;

      case 'lastCreated':
        channels = channels.sort(sortByLastCreated);
        break;

      case 'displayName':
        /*
         * The server returns channels with empty | null displayName's first before
         * returning sorted list of channels with displayNames
         *
         * This section needs to be updated as displayNames can be null as well
         */
        channels = channels
          // this needs to be aligned with the backend data type
          .map(c => (c.displayName ? c : { ...c, displayName: '' }))
          // @ts-ignore
          .sort(sortByDisplayName);
        break;

      default:
        channels = channels.sort(sortByLastActivity);
        break;
    }

    callback({
      onNextPage: onFetch,
      data: channels,
      hasNextPage: !!data.params?.page,
      loading: data.loading,
      error: data.error,
    });
  };

  const realtimeRouter = (_: Amity.ChannelActionType) => (channel: Amity.Channel) => {
    const collection = pullFromCache<Amity.ChannelLiveCollectionCache>(cacheKey)?.data;
    if (!collection) return;

    collection.data = [...new Set([channel.channelId, ...collection.data])];

    pushToCache(cacheKey, collection);
    responder(collection);
  };

  const onFetch = () => {
    const collection = pullFromCache<Amity.ChannelLiveCollectionCache>(cacheKey)?.data;

    const channels = collection?.data ?? [];

    if (channels.length > 0 && !collection?.params.page) return;

    const query = createQuery(queryChannels, {
      ...queryParams,
      page: collection?.params.page ?? { limit },
    });

    runQuery(
      query,
      ({ data: result, error, loading, nextPage: page }) => {
        const data = {
          loading,
          error,
          params: { page },
          data: channels,
        };

        if (result) {
          data.data = [...new Set([...channels, ...result.map(getResolver('channel'))])];
        }

        pushToCache(cacheKey, data);

        responder(data);
      },
      queryOptions(policy),
    );
  };

  disposers.push(
    onChannelCreated(realtimeRouter('onCreate')),
    onChannelDeleted(realtimeRouter('onDelete')),
    onChannelUpdated(realtimeRouter('onUpdate')),
    onChannelMuted(realtimeRouter('onMute')),
    onChannelJoined(realtimeRouter('onJoin')),
    onChannelLeft(realtimeRouter('onLeft')),
    onChannelMemberAdded(realtimeRouter('onMemberAdded')),
    onChannelMemberRemoved(realtimeRouter('onMemberRemoved')),
    onMessageCreated(() => null), // watch unread count
  );

  onFetch();

  return () => {
    log(`liveChannels(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};

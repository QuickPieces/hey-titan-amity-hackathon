/* eslint-disable no-use-before-define */
import { getResolver } from '~/core/model';
import { pullFromCache, pushToCache } from '~/cache/api';
import { getActiveClient } from '~/client/api';
import {
  createQuery,
  filterByPropEquality,
  queryOptions,
  runQuery,
  sortByFirstCreated,
  sortByLastCreated,
} from '~/core/query';
import {
  COLLECTION_DEFAULT_CACHING_POLICY,
  COLLECTION_DEFAULT_PAGINATION_LIMIT,
  ENABLE_CACHE_MESSAGE,
} from '~/utils/constants';
import {
  onChannelJoined,
  onChannelLeft,
  onChannelMemberAdded,
  onChannelMemberBanned,
  onChannelMemberRemoved,
  onChannelMemberUnbanned,
} from '../events';
import { queryChannelMembers } from '../api';

/**
 * ```js
 * import { liveChannelMembers } from '@amityco/ts-sdk'
 *
 * let channelMembers = []
 * const unsub = liveChannelMembers({
 *   channelId: Amity.Channel['channelId'],
 * }, response => merge(channelMembers, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.ChannelUser}s
 *
 * @param params for querying channel users
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the channel users
 *
 * @category Channel Live Collection
 */
export const liveChannelMembers = (
  params: Amity.ChannelMembersLiveCollection,
  callback: Amity.LiveCollectionCallback<Amity.Membership<'channel'>>,
  config?: Amity.LiveCollectionConfig,
) => {
  const { log, cache } = getActiveClient();

  if (!cache) {
    console.log(ENABLE_CACHE_MESSAGE);
  }

  const timestamp = Date.now();
  log(`liveChannelMembers(tmpid: ${timestamp}) > listen`);

  const { limit: queryLimit, ...queryParams } = params;

  const limit = queryLimit ?? COLLECTION_DEFAULT_PAGINATION_LIMIT;
  const { policy = COLLECTION_DEFAULT_CACHING_POLICY } = config ?? {};

  const disposers: Amity.Unsubscriber[] = [];
  const cacheKey = ['channelUsers', 'collection', { channelId: params.channelId }];

  const responder = (data: Amity.ChannelMembersLiveCollectionCache) => {
    let channelMembers: Amity.Membership<'channel'>[] =
      data.data
        .map(id => pullFromCache<Amity.Membership<'channel'>>(['channelUsers', 'get', id])!)
        .filter(Boolean)
        .map(({ data }) => data) ?? [];

    channelMembers = filterByPropEquality(channelMembers, 'roles', params.roles);

    if (params.memberships) {
      /*
       * even though membership includes muted as a possible value
       * when querying the server.
       * Muted is specified under seperarte property namely isMuted
       * Hence why I've seperately checked for it's equality
       */
      channelMembers = channelMembers.filter(member => {
        // @ts-ignore
        if (params.memberships.includes('muted') && member.isMuted) {
          return true;
        }

        // @ts-ignore
        return params.memberships.includes(member.membership);
      });
    }

    if (params.search) {
      const containsMatcher = new RegExp(params.search);
      channelMembers = channelMembers.filter(m => m.userId.match(containsMatcher));
    }

    // sort, 'lastCreated' is the default sort order
    const sortBy = params.sortBy ? params.sortBy : 'lastCreated';
    channelMembers = channelMembers.sort(
      sortBy === 'lastCreated' ? sortByLastCreated : sortByFirstCreated,
    );

    callback({
      onNextPage: onFetch,
      data: channelMembers,
      hasNextPage: !!data.params?.page,
      loading: data.loading,
      error: data.error,
    });
  };

  const realtimeRouter =
    (action: Amity.ChannelMemberActionType) =>
    (channel: Amity.Channel, channelMember: Amity.Membership<'channel'>) => {
      if (params.channelId !== channelMember.channelId) {
        return;
      }

      const collection = pullFromCache<Amity.ChannelMembersLiveCollectionCache>(cacheKey)?.data;
      if (!collection) return;

      const channelMemberCacheId = getResolver('channelUsers')({
        channelId: params.channelId,
        userId: channelMember.userId,
      });

      if (channelMember.membership === 'none') {
        collection.data = collection.data.filter(m => m !== channelMemberCacheId);
      } else if (!collection.data.includes(channelMemberCacheId)) {
        collection.data = [channelMemberCacheId, ...collection.data];
      }

      pushToCache(cacheKey, collection);
      responder(collection);
    };

  const onFetch = () => {
    const collection = pullFromCache<Amity.ChannelMembersLiveCollectionCache>(cacheKey)?.data;

    const channelMembers = collection?.data ?? [];

    if (channelMembers.length > 0 && !collection?.params.page) return;

    const query = createQuery(queryChannelMembers, {
      ...queryParams,
      page: collection?.params.page ?? { limit },
    });

    runQuery(
      query,
      ({ data: result, error, loading, nextPage: page }) => {
        const data = {
          loading,
          error,
          params: { page },
          data: channelMembers,
        };

        if (result) {
          data.data = [...new Set([...channelMembers, ...result.map(getResolver('channelUsers'))])];
        }

        pushToCache(cacheKey, data);

        responder(data);
      },
      queryOptions(policy),
    );
  };

  disposers.push(
    onChannelJoined(realtimeRouter('onJoin')),
    onChannelLeft(realtimeRouter('onLeft')),
    onChannelMemberAdded(realtimeRouter('onMemberAdded')),
    onChannelMemberRemoved(realtimeRouter('onMemberRemoved')),
    onChannelMemberBanned(realtimeRouter('onChannelMemberBanned')),
    onChannelMemberUnbanned(realtimeRouter('onChannelMemberUnbanned')),
  );

  onFetch();

  return () => {
    log(`liveChannelMembers(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};

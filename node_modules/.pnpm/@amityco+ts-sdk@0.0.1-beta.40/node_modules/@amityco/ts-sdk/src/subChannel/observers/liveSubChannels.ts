/* eslint-disable no-use-before-define */
import { getActiveClient } from '~/client/api';
import {
  createQuery,
  runQuery,
  queryOptions,
  filterByPropEquality,
  sortByLastActivity,
} from '~/core/query';
import {
  COLLECTION_DEFAULT_CACHING_POLICY,
  COLLECTION_DEFAULT_PAGINATION_LIMIT,
  ENABLE_CACHE_MESSAGE,
} from '~/utils/constants';
import { onSubChannelFetched } from '~/subChannel/events/onSubChannelFetched';
import { isCollectionOutdated, merge } from '~/utils';
import { onSubChannelCreated, onSubChannelDeleted, onSubChannelUpdated } from '../events';
import { querySubChannels } from '../api';

/**
 * ```js
 * import { liveSubChannels } from '@amityco/ts-sdk';
 *
 * let subChannels = [];
 *
 * const unsubscribe = liveSubChannels({ channelId }, response => {
 *   merge(subChannels, response.data);
 * });
 * ```
 *
 * Observe all mutations on a list of {@link Amity.SubChannel}s
 *
 * @param params for querying sub channels
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the sub channels
 *
 * @category SubChannel Live Collection
 */
export const liveSubChannels = (
  params: Amity.SubChannelLiveCollection,
  callback: Amity.LiveCollectionCallback<Amity.SubChannel>,
  config?: Amity.LiveCollectionConfig,
) => {
  const { log, cache } = getActiveClient();
  const timestamp = Date.now();
  log(`liveSubChannels(tmpid: ${timestamp}) > listen`);

  if (!cache) {
    console.log(ENABLE_CACHE_MESSAGE);
  }

  const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT, ...queryParams } = params;
  const { policy = COLLECTION_DEFAULT_CACHING_POLICY } = config ?? {};

  let snapshot: Amity.SubChannelLiveCollectionCache;
  const disposers: Amity.Unsubscriber[] = [];

  const responder = (data: Amity.SubChannelLiveCollectionCache) => {
    let subChannels: Amity.SubChannel[] = data.data;

    if (params.isDeleted !== undefined) {
      subChannels = filterByPropEquality(subChannels, 'isDeleted', params.isDeleted);
    }

    subChannels.sort(sortByLastActivity);

    callback({
      onNextPage: onFetch,
      data: subChannels,
      hasNextPage: !!data.params?.page,
      loading: data.loading,
      error: data.error,
    });
  };

  const realtimeRouter = (action: Amity.ChannelActionType) => (subChannel: Amity.SubChannel) => {
    if (
      params.channelId !== subChannel.channelId ||
      !snapshot ||
      !isCollectionOutdated(snapshot.data, subChannel, action)
    ) {
      return;
    }

    if (action === 'onCreate') {
      snapshot.data = [subChannel, ...snapshot.data];
    } else {
      snapshot.data = snapshot.data.map(x =>
        x.subChannelId === subChannel.subChannelId ? subChannel : x,
      );
    }

    responder(snapshot);
  };

  const onFetch = () => {
    const subChannels = snapshot ? snapshot.data : [];

    if (subChannels.length > 0 && !snapshot?.params.page) {
      return;
    }

    const query = createQuery(querySubChannels, {
      ...queryParams,
      page: snapshot?.params.page ?? { limit },
    });

    runQuery(
      query,
      ({ data: result, error, loading, nextPage: page }) => {
        snapshot = {
          loading,
          error,
          params: { page },
          data: result ? merge(subChannels, result) : subChannels,
        };

        responder(snapshot);
      },
      queryOptions(policy),
    );
  };

  disposers.push(
    onSubChannelCreated(realtimeRouter('onCreate')),
    onSubChannelDeleted(realtimeRouter('onDelete')),
    onSubChannelFetched(realtimeRouter('onFetch')),
    onSubChannelUpdated(realtimeRouter('onUpdate')),
  );

  onFetch();

  return () => {
    log(`liveSubChannels(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};

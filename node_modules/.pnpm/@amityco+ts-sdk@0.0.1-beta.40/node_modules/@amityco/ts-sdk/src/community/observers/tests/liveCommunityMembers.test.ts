import { disableCache, enableCache } from '~/cache/api';

import {
  client,
  connectClient,
  disconnectClient,
  pause,
  user11,
  user13,
  community11,
  communityUser11,
  communityUser13,
  withRoleCommunityUser,
  bannedCommunityUser,
  communityUserQueryResponse,
  communityUserQueryResponsePage2,
  convertedCommunityUser1,
  convertedCommunityUser2,
  convertedCommunityUser3,
} from '~/utils/tests';

import { liveCommunityMembers } from '../liveCommunityMembers';

const getSnapshot = (params?: Record<string, any>) => {
  return {
    data: [] as Amity.Membership<'community'>[],
    loading: true,
    error: undefined as any,
    ...params,
  };
};

describe('liveCommunityMembers', () => {
  beforeAll(connectClient);
  afterAll(disconnectClient);

  beforeEach(enableCache);
  afterEach(disableCache);

  const { communityId } = community11;

  test('it should return community members collection', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(communityUserQueryResponse);

    liveCommunityMembers({ communityId }, callback);
    await pause();

    expect(callback).toHaveBeenNthCalledWith(1, expect.objectContaining(getSnapshot()));
    expect(callback).toHaveBeenNthCalledWith(
      2,
      expect.objectContaining(
        getSnapshot({ data: [convertedCommunityUser2, convertedCommunityUser1], loading: false }),
      ),
    );
  });

  const filters: [string, Amity.CommunityMemberLiveCollection, Amity.Membership<'community'>[]][] =
    [
      ['roles', { communityId, roles: ['test-role'] }, [withRoleCommunityUser]],
      [
        'searched term',
        { communityId, search: 'use' },
        [withRoleCommunityUser, bannedCommunityUser],
      ],
      ['member', { communityId, membership: ['member'] }, [withRoleCommunityUser]],
      ['banned members', { communityId, membership: ['banned'] }, [bannedCommunityUser]],
    ];

  test.each(filters)('it should filter channelUsers by %s', async (filter, params, expected) => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(communityUserQueryResponsePage2);

    liveCommunityMembers(params, callback);
    await pause();

    expect(callback).toHaveBeenNthCalledWith(1, expect.objectContaining(getSnapshot()));
    expect(callback).toHaveBeenNthCalledWith(
      2,
      expect.objectContaining({ data: expected, loading: false }),
    );
  });

  test('it should return method to fetch next page', async () => {
    const callback = jest.fn();
    client.http.get = jest
      .fn()
      .mockResolvedValue(communityUserQueryResponse)
      .mockResolvedValueOnce(communityUserQueryResponsePage2);

    liveCommunityMembers({ communityId, sortBy: 'firstCreated' }, callback);
    await pause();

    expect(callback).toHaveBeenCalled();
    expect(callback.mock.lastCall).toHaveLength(1);

    const { onNextPage, hasNextPage } = callback.mock.lastCall[0];

    expect(hasNextPage).toBe(true);
    expect(onNextPage).toBeTruthy();

    onNextPage();
    await pause();

    const payload = [convertedCommunityUser1, convertedCommunityUser2];
    const payload2 = [withRoleCommunityUser, bannedCommunityUser];

    const snapshot = getSnapshot();
    snapshot.loading = false;
    snapshot.data = [...payload2, ...payload];

    expect(callback).toHaveBeenNthCalledWith(4, expect.objectContaining(snapshot));
  });

  const events: [
    string,
    keyof Amity.Events,
    Amity.RawMembership<'community'>,
    Amity.User,
    Amity.Membership<'community'>[],
  ][] = [
    [
      'it should add new member to collection onJoined',
      'community.joined',
      communityUser13,
      user13,
      [convertedCommunityUser1, convertedCommunityUser3, convertedCommunityUser2],
    ],
    [
      'it should remove member from collection onLeft',
      'community.left',
      { ...communityUser11, communityMembership: 'none' },
      user11,
      [{ ...convertedCommunityUser1, communityMembership: 'none' }, convertedCommunityUser2],
    ],
    [
      'it should add new member to collection onMemberCountChanged',
      'community.userChanged',
      communityUser13,
      user13,
      [convertedCommunityUser1, convertedCommunityUser3, convertedCommunityUser2],
    ],
    [
      'it should update member in collection onMemberCountChanged',
      'community.userChanged',
      { ...communityUser13, communityMembership: 'none' },
      user13,
      [
        convertedCommunityUser1,
        { ...convertedCommunityUser3, communityMembership: 'none' },
        convertedCommunityUser2,
      ],
    ],
    [
      'it should update member membership on ban',
      'community.userBanned',
      { ...communityUser11, communityMembership: 'banned' },
      user11,
      [{ ...convertedCommunityUser1, communityMembership: 'banned' }, convertedCommunityUser2],
    ],
    [
      'it should update membership on Unban',
      'community.userUnbanned',
      communityUser13,
      user13,
      [convertedCommunityUser1, convertedCommunityUser3, convertedCommunityUser2],
    ],
  ];

  test.each(events)('%s', async (test, event, communityUserRaw, user, expected) => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(communityUserQueryResponse);

    liveCommunityMembers({ communityId, sortBy: 'firstCreated' }, callback);
    await pause();

    client.emitter.emit(event, {
      communities: [community11],
      communityUsers: [communityUserRaw],
      users: [user],
      files: [],
    });
    await pause();

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining(
        getSnapshot({
          data: expected,
          loading: false,
        }),
      ),
    );
  });
});

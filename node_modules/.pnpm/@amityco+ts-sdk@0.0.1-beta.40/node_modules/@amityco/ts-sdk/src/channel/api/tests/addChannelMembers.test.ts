import { getResolver } from '~/core/model';
import { pullFromCache, enableCache, disableCache } from '~/cache/api';

import {
  client,
  pause,
  channelUserQueryResponse,
  rawChannelUser,
  rawChannelUser3,
  channel1,
  user11,
  channelUser,
} from '~/utils/tests';

import { onChannelMemberAdded } from '~/channel/events';
import { addChannelMembers } from '../addChannelMembers';

describe('addChannelMembers', () => {
  const { channelId } = channelUserQueryResponse.data.channels[0];
  const { userId } = rawChannelUser;

  test('it should add channel members in channel', async () => {
    client.http.post = jest.fn().mockResolvedValueOnce(channelUserQueryResponse);

    const recieved = await addChannelMembers(channelId, [userId]);

    expect(recieved).toBe(true);
  });

  test('it should update cache with channel members', async () => {
    enableCache();

    client.http.post = jest.fn().mockResolvedValueOnce(channelUserQueryResponse);

    const channelUserCacheKey = getResolver('channelUsers')({
      channelId,
      userId,
    });

    const recieved = await addChannelMembers(channelId, [userId]);
    const recievedCache = pullFromCache<Amity.Membership<'channel'>>([
      'channelUsers',
      'get',
      channelUserCacheKey,
    ])?.data;

    expect(recieved).toBe(true);
    expect(recievedCache).toBeDefined();
    expect(recievedCache).toEqual(channelUser);

    disableCache();
  });

  test('it should fire event when new members added', async () => {
    expect.assertions(1);

    client.http.post = jest.fn().mockResolvedValueOnce(channelUserQueryResponse);
    let dispose;

    const callback = new Promise(resolve => {
      dispose = onChannelMemberAdded(resolve);
    }).finally(dispose);

    await addChannelMembers(channelId, [userId]);

    return expect(callback).resolves.not.toThrow();
  });

  test('it should fire event with all new members', async () => {
    client.http.post = jest.fn().mockResolvedValueOnce(channelUserQueryResponse);

    const callback = jest.fn();
    const { userId: userId2 } = rawChannelUser3;
    const unsub = onChannelMemberAdded(callback);

    const recieved = await addChannelMembers(channelId, [userId, userId2]);

    expect(recieved).toBe(true);

    await pause();

    /*
     * Assertion below is required to check if the event handler is called with the right
     * params. It's not enough to check if the handler does not throw
     */
    expect(callback).toHaveBeenNthCalledWith(1, { ...channel1 }, { ...rawChannelUser });

    unsub();
  });

  test('it should fire event with all new members by attaching a user', async () => {
    enableCache();
    client.http.post = jest.fn().mockResolvedValueOnce(channelUserQueryResponse);

    const callback = jest.fn();
    const { userId: userId2 } = rawChannelUser3;
    const unsub = onChannelMemberAdded(callback);

    const recieved = await addChannelMembers(channelId, [userId, userId2]);

    expect(recieved).toBe(true);

    await pause();

    /*
     * Assertion below is required to check if the event handler is called with the right
     * params. It's not enough to check if the handler does not throw
     */
    expect(callback).toHaveBeenNthCalledWith(
      1,
      { ...channel1 },
      { ...rawChannelUser, user: user11 },
    );

    unsub();
    disableCache();
  });

  test('it should return an error', async () => {
    client.http.post = jest.fn().mockRejectedValueOnce(new Error('error'));

    await expect(addChannelMembers('channelId', [])).rejects.toThrow('error');
  });
});

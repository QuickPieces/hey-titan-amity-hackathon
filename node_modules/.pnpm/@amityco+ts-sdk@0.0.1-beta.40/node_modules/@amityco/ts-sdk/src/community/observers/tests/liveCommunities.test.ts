import { disableCache, enableCache } from '~/cache/api';
import {
  communityQueryResponse,
  communityQueryResponsePage2,
  client,
  connectClient,
  disconnectClient,
  pause,
  communityUser11,
  emptyCommunityPayload,
} from '~/utils/tests';

import { liveCommunities } from '../liveCommunities';
import { prepareCommunityPayload } from '../../utils';

const getSnapshot = (params?: Record<string, any>) => {
  return {
    data: [] as Amity.Community[],
    loading: true,
    error: undefined as any,
    ...params,
  };
};

const { paging, ...payload } = communityQueryResponse.data;

const community1 = prepareCommunityPayload(payload).communities[0];
const community2 = prepareCommunityPayload(payload).communities[1];

describe('liveCommunities', () => {
  beforeAll(connectClient);
  afterAll(disconnectClient);

  beforeEach(enableCache);

  afterEach(disableCache);

  test('it should return community collection', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(communityQueryResponse);

    liveCommunities({}, callback);
    await pause();

    expect(callback).toHaveBeenCalledTimes(2);
    expect(callback).toHaveBeenNthCalledWith(1, expect.objectContaining(getSnapshot()));
    expect(callback).toHaveBeenNthCalledWith(
      2,
      expect.objectContaining(
        getSnapshot({
          data: prepareCommunityPayload(payload).communities,
          loading: false,
        }),
      ),
    );
  });

  test('it should return data from cache', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(communityQueryResponse);

    liveCommunities({}, () => undefined);
    await pause();
    liveCommunities({}, callback);
    await pause();

    expect(callback).toHaveBeenCalledTimes(2);
    expect(callback).toHaveBeenNthCalledWith(
      1,
      expect.objectContaining(
        getSnapshot({
          data: prepareCommunityPayload(payload).communities,
        }),
      ),
    );
    expect(callback).toHaveBeenNthCalledWith(
      2,
      expect.objectContaining(
        getSnapshot({
          data: prepareCommunityPayload(payload).communities,
          loading: false,
        }),
      ),
    );
  });

  const filters: [string, Amity.CommunityLiveCollection, Amity.Community[]][] = [
    ['deleted', { isDeleted: true }, [community1]],
    ['categoryId', { categoryId: 'test-category-id' }, [community1]],
    ['displayName', { displayName: 'community 1' }, [community1]],
    ['tagged', { tags: ['test-community-tag'] }, [community1]],
    ['member', { membership: 'member' }, [community1]],
    ['not member', { membership: 'notMember' }, [community2]],
    ['all membership', { membership: 'all' }, [community1, community2]],
  ];

  test.each(filters)('it should filter by %s communities', async (filter, params, expected) => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(communityQueryResponse);

    liveCommunities(params, callback);

    expect(callback).toHaveBeenCalledTimes(1);
    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(expect.objectContaining(getSnapshot()));

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);
    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining(
        getSnapshot({
          loading: false,
          data: expected,
        }),
      ),
    );
  });

  test('it should return method to fetch next page', async () => {
    const callback = jest.fn();
    client.http.get = jest
      .fn()
      .mockResolvedValue(communityQueryResponse)
      .mockResolvedValueOnce(communityQueryResponsePage2);

    liveCommunities({}, callback);
    await pause();

    expect(callback).toHaveBeenCalled();
    expect(callback.mock.lastCall).toHaveLength(1);

    const { onNextPage, hasNextPage } = callback.mock.lastCall[0];

    expect(hasNextPage).toBe(true);
    expect(onNextPage).toBeTruthy();

    onNextPage();
    await pause();

    // 4 -> because 1 local & server call each per call (2)
    expect(callback).toHaveBeenCalledTimes(4);
    expect(callback).toHaveBeenNthCalledWith(
      4,
      expect.objectContaining(
        getSnapshot({
          loading: false,
          data: prepareCommunityPayload(payload).communities,
        }),
      ),
    );
  });

  describe('events', () => {
    const newCommunityPayload = {
      ...communityQueryResponse.data.communities[0],
      communityId: 'new-community',
      isDeleted: false,
    };

    const newCommunity = prepareCommunityPayload({
      ...emptyCommunityPayload,
      communities: [newCommunityPayload],
    }).communities[0];

    const communityPayload = {
      ...emptyCommunityPayload,
      communities: [communityQueryResponse.data.communities[0]],
      communityUsers: [communityUser11],
    };

    const cases: [string, keyof Amity.Events, Amity.CommunityPayload, Amity.Community[]][] = [
      [
        'it should add new community to collection onCreate',
        'community.created',
        {
          ...emptyCommunityPayload,
          communities: [newCommunityPayload],
        },
        [newCommunity, community2],
      ],
      [
        'it should update community in collection onUpdate',
        'community.updated',
        {
          ...emptyCommunityPayload,
          communities: [{ ...newCommunityPayload, communityId: community1.communityId }],
        },
        [{ ...newCommunity, communityId: community1.communityId }, community2],
      ],
      [
        'it should remove community from collection onDelete',
        'community.deleted',
        communityPayload,
        [community2],
      ],
    ];

    test.each(cases)('%s', async (test, event, communityPayload, expected) => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue(communityQueryResponse);

      liveCommunities({ isDeleted: false }, callback);
      await pause();

      client.emitter.emit(event, communityPayload);
      await pause();

      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining(
          getSnapshot({
            data: expected,
            loading: false,
          }),
        ),
      );
    });

    const joinCommunityPayload = {
      ...communityQueryResponse.data.communities[0],
      communityId: 'joining-community',
      isDeleted: false,
    };

    const joinedCommunity = prepareCommunityPayload({
      ...emptyCommunityPayload,
      communities: [joinCommunityPayload],
    }).communities[0];

    const joiningUser: Amity.RawMembership<'community'> = {
      ...communityUser11,
      userId: 'test',
      communityId: 'joining-community',
      communityMembership: 'member',
    };

    const memberEvents: [
      string,
      Amity.CommunityLiveCollection,
      keyof Amity.Events,
      Amity.CommunityPayload,
      Amity.Community[],
    ][] = [
      [
        'it should add new community to collection onJoin',
        { membership: 'member' },
        'community.joined',
        {
          ...emptyCommunityPayload,
          communities: [joinCommunityPayload],
          communityUsers: [joiningUser],
        },
        [joinedCommunity, community1],
      ],
      [
        'it should not add new member to community collection onJoin if membership:not member',
        { membership: 'notMember' },
        'community.joined',
        {
          ...emptyCommunityPayload,
          communities: [joinCommunityPayload],
          communityUsers: [joiningUser],
        },
        [],
      ],
      [
        'it should update community in collection onLeft',
        { membership: 'member' },
        'community.left',
        { ...communityPayload, communities: [{ ...community1, isJoined: false }] },
        [],
      ],
      [
        'it should add new community in collection onLeft and if membership:not member',
        { membership: 'notMember' },
        'community.left',
        { ...communityPayload, communities: [{ ...community1, isJoined: false }] },
        [{ ...community1, isJoined: false }],
      ],
    ];

    test.each(memberEvents)('%s', async (test, params, event, communityPayload, expected) => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue(communityQueryResponsePage2);

      liveCommunities(params, callback);
      await pause();

      client.emitter.emit(event, communityPayload);
      await pause();

      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining(
          getSnapshot({
            data: expected,
            loading: false,
          }),
        ),
      );
    });
  });
});

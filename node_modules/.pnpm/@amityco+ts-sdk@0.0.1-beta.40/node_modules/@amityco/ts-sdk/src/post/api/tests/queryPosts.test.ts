import { getResolver } from '~/core/model';

import { disableCache, enableCache, pushToCache } from '~/cache/api';
import { ingestInCache } from '~/cache/api/ingestInCache';

import { client, postQueryResponse, post11 } from '~/utils/tests';

import { queryPosts } from '../queryPosts';

const { targetId, targetType } = post11;
const params = { targetId, targetType };

describe('queryPosts', () => {
  test('it should return posts', async () => {
    const { posts: expected } = postQueryResponse.data;
    client.http.get = jest.fn().mockResolvedValue(postQueryResponse);

    const { data } = await queryPosts(params);

    expect(data).toEqual(expected);
  });

  test('it should throw error', async () => {
    client.http.get = jest.fn().mockRejectedValueOnce(new Error('error'));

    await expect(queryPosts(params)).rejects.toThrow('error');
  });

  test('it should send matchingOnlyParentPost as true if there are no dataTypes', async () => {
    const mockFn = jest.fn();
    client.http.get = mockFn.mockResolvedValue(postQueryResponse);

    await queryPosts(params);

    const mockFnParams = mockFn.mock.lastCall;

    expect(mockFnParams).toBeDefined();
    expect(mockFnParams).toHaveLength(2);
    expect(mockFnParams[1].params.matchingOnlyParentPost).toBe(true);
  });

  test('it should send matchingOnlyParentPost as false if there are dataTypes', async () => {
    const mockFn = jest.fn();
    client.http.get = mockFn.mockResolvedValue(postQueryResponse);

    await queryPosts({ ...params, dataTypes: ['image'] });

    const mockFnParams = mockFn.mock.lastCall;

    expect(mockFnParams).toBeDefined();
    expect(mockFnParams).toHaveLength(2);
    expect(mockFnParams[1].params.matchingOnlyParentPost).toBe(false);
  });

  test('it should update cache upon fetching data from server', async () => {
    enableCache();

    client.http.get = jest.fn().mockResolvedValue(postQueryResponse);

    const { data: expected } = await queryPosts(params);
    const { data: received } = queryPosts.locally(params)!;

    expect(received).toBeDefined();
    expect(received).toEqual(expected);

    disableCache();
  });
});

describe('queryPosts.locally', () => {
  const cacheKey = ['post', 'query', { ...params, options: { limit: 10 } } as Amity.Serializable];

  test('it should fetch query locally if present in cache', () => {
    enableCache();

    const { data } = postQueryResponse;
    const { paging, ...payload } = data;
    const { posts: expected } = payload;

    ingestInCache(payload as Amity.ProcessedPostPayload);

    pushToCache(cacheKey, { posts: expected.map(getResolver('post')), paging });

    const { data: received } = queryPosts.locally(params)!;

    expect(received).toBeDefined();
    expect(received).toEqual(expected);

    disableCache();
  });

  test('it should return undefined if only partial data in cache', () => {
    enableCache();

    const { data } = postQueryResponse;
    const { posts, paging } = data;

    // ingest incomplete data
    ingestInCache({
      ...data,
      posts: [data.posts[0]],
    } as Amity.ProcessedPostPayload);

    pushToCache(cacheKey, {
      posts: posts.map(getResolver('post')),
      paging,
    });

    const received = queryPosts.locally(params)!;

    expect(received).toBeUndefined();

    disableCache();
  });

  // added because of comment above cache key in queryPosts
  test('it should return undefined if params do not match', () => {
    enableCache();

    const { data } = postQueryResponse;
    const { posts: expected, paging } = data;

    ingestInCache(data as Amity.ProcessedPostPayload);

    pushToCache(cacheKey, { posts: expected.map(getResolver('post')), paging });

    const { data: received } = queryPosts.locally(params)!;
    const received2 = queryPosts.locally({ ...params, targetId: 'does-not-exist' })!;

    expect(received).toBeDefined();
    expect(received).toEqual(expected);
    expect(received2).toBeUndefined();

    disableCache();
  });

  test('it should return undefined if data not in cache', () => {
    enableCache();

    const received = queryPosts.locally(params);

    expect(received).toBeUndefined();

    disableCache();
  });

  test('it should return undefined if cache disabled', () => {
    expect(queryPosts.locally(params)).toBeUndefined();
  });
});

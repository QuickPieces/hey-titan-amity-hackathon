import { CommunityPostSettingMaps, DefaultCommunityPostSetting } from '~/@types';
import { withUsers } from '~/group/utils';

const getMatchPostSetting = (value: {
  needApprovalOnPostCreation: Amity.RawCommunity['needApprovalOnPostCreation'];
  onlyAdminCanPost: Amity.RawCommunity['onlyAdminCanPost'];
}): Amity.Community['postSetting'] =>
  Object.keys(CommunityPostSettingMaps).find(
    key =>
      value.needApprovalOnPostCreation ===
        CommunityPostSettingMaps[key].needApprovalOnPostCreation &&
      value.onlyAdminCanPost === CommunityPostSettingMaps[key].onlyAdminCanPost,
  ) ?? DefaultCommunityPostSetting;

export const prepareCommunityPayload = (
  rawPayload: Amity.CommunityPayload,
): Amity.ProcessedCommunityPayload => {
  // Unpack community payload by mapping payload field to postSetting value.
  const communities = rawPayload.communities.map<Amity.Community>(
    ({ needApprovalOnPostCreation, onlyAdminCanPost, ...restCommunityPayload }) => ({
      postSetting: getMatchPostSetting({
        needApprovalOnPostCreation,
        onlyAdminCanPost,
      }),
      ...restCommunityPayload,
    }),
  );

  const communityUsers = withUsers(rawPayload.communityUsers);

  return {
    ...rawPayload,
    communities,
    communityUsers,
  };
};

export const prepareCommunityRequest = <
  T extends { postSetting?: Amity.Community['postSetting']; [k: string]: any },
>(
  params: T,
) => {
  const { postSetting = undefined, ...restParam } = params;

  return {
    ...restParam,
    // Repack community payload by mapping postSetting to the actual value.
    ...(postSetting ? CommunityPostSettingMaps[postSetting] : undefined),
  };
};

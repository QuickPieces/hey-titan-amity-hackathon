import { getActiveClient } from '~/client/api';

import { pullFromCache } from '~/cache/api';
import { ingestInCache } from '~/cache/api/ingestInCache';
import { fireEvent } from '~/core/events';

/**
 * ```js
 * import { getUsers } from '@amityco/ts-sdk'
 * const { data: users } = await getUsers(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.User} objects
 *
 * @param userIds the IDs of the {@link Amity.User} to fetch
 * @returns the associated collection of {@link Amity.User} objects
 *
 * @category User API
 * @async
 */
export const getUsers = async (
  userIds: Amity.User['userId'][],
): Promise<Amity.Cached<Amity.User[]>> => {
  const client = getActiveClient();
  client.log('user/getUsers', userIds);

  const encodedUserIds = userIds.map(userId => encodeURIComponent(userId));

  // API-FIX: endpoint should not be /list, parameters should be querystring.
  const { data } = await client.http.get<Amity.UserPayload>(`/api/v3/users/list`, {
    params: { userIds: encodedUserIds },
  });

  const cachedAt = client.cache && Date.now();
  if (client.cache) ingestInCache(data, { cachedAt });

  fireEvent('user.fetched', data);

  return {
    data: data.users,
    cachedAt,
  };
};

/**
 * ```js
 * import { getUsers } from '@amityco/ts-sdk'
 * const { data: users } = getUsers.locally!(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.User} objects from cache
 *
 * @param userIds the IDs of the {@link Amity.User} to fetch
 * @returns the associated collection of {@link Amity.User} objects
 *
 * @category User API
 */
getUsers.locally = (userIds: Amity.User['userId'][]): Amity.Cached<Amity.User[]> | undefined => {
  const client = getActiveClient();
  client.log('user/getUsers.locally', userIds);

  if (!client.cache) return;

  const cached = userIds
    .map(userId => pullFromCache<Amity.User>(['user', 'get', userId])!)
    .filter(Boolean);

  const users = cached.map(({ data }) => data);
  const oldest = cached.sort((a, b) => (a.cachedAt! < b.cachedAt! ? -1 : 1))?.[0];

  if (cached?.length < userIds.length) return;

  return {
    data: users,
    cachedAt: oldest.cachedAt,
  };
};

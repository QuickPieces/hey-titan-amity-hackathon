/* eslint-disable no-use-before-define */
import { getResolver } from '~/core/model';
import { getActiveClient } from '~/client/api';
import { pushToCache, pullFromCache } from '~/cache/api';
import {
  createQuery,
  runQuery,
  queryOptions,
  filterByPropEquality,
  filterByFeedType,
  sortByFirstCreated,
  sortByLastCreated,
} from '~/core/query';

import {
  COLLECTION_DEFAULT_CACHING_POLICY,
  COLLECTION_DEFAULT_PAGINATION_LIMIT,
  ENABLE_CACHE_MESSAGE,
} from '~/utils/constants';

import {
  onPostCreated,
  onPostUpdated,
  onPostDeleted,
  onPostApproved,
  onPostDeclined,
  onPostFlagged,
  onPostUnflagged,
  onPostReactionAdded,
  onPostReactionRemoved,
} from '../events';
import { queryPosts } from '../api';

/**
 * ```js
 * import { livePosts } from '@amityco/ts-sdk'
 *
 * let posts = []
 * const unsub = livePosts({
 *   targetType: Amity.PostTargetType,
 *   targetId: Amity.Post['targetId'],
 * }, response => merge(posts, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Post} for a given target object
 *
 * @param param.targetType the type of the target
 * @param param.targetId the ID of the target
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the messages
 *
 * @category Posts Live Collection
 */
export const livePosts = (
  params: Amity.PostLiveCollection,
  callback: Amity.LiveCollectionCallback<Amity.Post>,
  config?: Amity.LiveCollectionConfig,
): Amity.Unsubscriber => {
  const { log, cache } = getActiveClient();

  if (!cache) {
    console.log(ENABLE_CACHE_MESSAGE);
  }

  const timestamp = Date.now();
  log(`livePosts(tmpid: ${timestamp}) > listen`);

  const { limit: queryLimit, ...queryParams } = params;

  const limit = queryLimit ?? COLLECTION_DEFAULT_PAGINATION_LIMIT;
  const { policy = COLLECTION_DEFAULT_CACHING_POLICY } = config ?? {};

  const disposers: Amity.Unsubscriber[] = [];
  const cacheKey = [
    'post',
    'collection',
    { targetId: params.targetId, targetType: params.targetType },
  ];

  const responder = (data: Amity.PostLiveCollectionCache) => {
    let posts: Amity.Post[] =
      data.data
        .map(postId => pullFromCache<Amity.Post>(['post', 'get', postId])!)
        .filter(Boolean)
        .map(({ data }) => data) ?? [];

    posts = filterByPropEquality(posts, 'isDeleted', params.isDeleted);

    const sortBy = params.sortBy ? params.sortBy : 'lastCreated';
    posts = posts.sort(sortBy === 'lastCreated' ? sortByLastCreated : sortByFirstCreated);

    if (params.tags) {
      posts = posts.filter(p => p.tags?.some(t => params.tags?.includes(t)));
    }

    if (params.targetType === 'community' && params.feedType) {
      posts = filterByFeedType(posts, params.feedType);
    }

    callback({
      onNextPage: onFetch,
      data: posts,
      hasNextPage: !!data.params?.page,
      loading: data.loading,
      error: data.error,
    });
  };

  const realtimeRouter = (action: Amity.PostActionType) => (post: Amity.Post) => {
    const collection = pullFromCache<Amity.PostLiveCollectionCache>(cacheKey)?.data;

    if (params.targetId !== post.targetId || params.targetType !== post.targetType || !collection)
      return;

    /*
     * This is not ideal, but currently this is the only way to update the
     * collection on post declined
     */
    if (action === 'onDeclined') {
      collection.data = collection.data.filter(postId => postId !== post.postId);
    } else {
      collection.data = [...new Set([post.postId, ...collection.data])];
    }

    pushToCache(cacheKey, collection);

    responder(collection);
  };

  const onFetch = () => {
    const collection = pullFromCache<Amity.PostLiveCollectionCache>(cacheKey)?.data;

    const posts = collection?.data ?? [];

    if (posts.length > 0 && !collection?.params?.page) return;

    const query = createQuery(queryPosts, {
      ...queryParams,
      page: collection?.params?.page ?? { limit },
    });

    runQuery(
      query,
      ({ data: result, error, loading, nextPage: page }) => {
        const data = {
          loading,
          error,
          params: { page },
          data: posts,
        };

        if (result) {
          data.data = [...new Set([...posts, ...result.map(getResolver('post'))])];
        }

        pushToCache(cacheKey, data);

        responder(data);
      },
      queryOptions(policy),
    );
  };

  disposers.push(
    onPostCreated(realtimeRouter('onCreate')),
    onPostApproved(realtimeRouter('onApproved')),
    onPostDeclined(realtimeRouter('onDeclined')),
    onPostDeleted(realtimeRouter('onDelete')),

    onPostUpdated(realtimeRouter('onUpdate')),
    onPostFlagged(realtimeRouter('onFlagged')),
    onPostUnflagged(realtimeRouter('onUnflagged')),
    onPostReactionAdded(realtimeRouter('onReactionAdded')),
    onPostReactionRemoved(realtimeRouter('onReactionRemoved')),
  );

  onFetch();

  return () => {
    log(`livePosts(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};

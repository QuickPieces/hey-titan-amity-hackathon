import { AxiosResponse } from 'axios';
import { toToken } from '~/core/query';
import { pullFromCache } from '~/cache/api';
import { prepareMessagePayloadForCache } from '~/reaction/utils/prepareMessagePayloadForCache';

export function convertFromRaw({
  channelPublicId,
  childCount,
  creatorPublicId,
  mentionedUsers,
  messageFeedId,
  myReactions,
  reactionCount,
  reactions,
  referenceId,
  segment,
  ...rest
}: Amity.RawMessage): Amity.Message {
  let cache: Amity.CacheEntry<Amity.Message> | undefined;

  if (referenceId) {
    try {
      cache = pullFromCache(['message', 'get', referenceId]);
      // eslint-disable-next-line no-empty
    } catch {}
  }

  if (!cache) {
    try {
      cache = pullFromCache(['message', 'get', rest.messageId]);
      // eslint-disable-next-line no-empty
    } catch {}
  }

  const out: Amity.Message = {
    ...rest,
    channelId: channelPublicId,
    channelSegment: segment,
    childrenNumber: childCount,
    creatorId: creatorPublicId,
    reactions: reactions ?? {},
    reactionsCount: reactionCount,
    subChannelId: messageFeedId,
    uniqueId: cache ? cache.data.uniqueId : rest.messageId,
  };

  if (mentionedUsers) {
    out.mentionees = mentionedUsers.map(mention => {
      if (mention.type === 'channel') {
        return mention;
      }

      return { type: 'user', userIds: mention.userPublicIds };
    });
  }

  if (myReactions) {
    // http response
    out.myReactions = myReactions;
  } else {
    // mqtt event
    try {
      prepareMessagePayloadForCache(out);
      // eslint-disable-next-line no-empty
    } catch {}
  }

  return out;
}

export const prepareMessagePayload = (
  payload: Amity.MessagePayload,
): Amity.ProcessedMessagePayload => {
  return {
    ...payload,
    messages: payload.messages.map(convertFromRaw),
  };
};

export const convertResponseFromRaw = <T extends Amity.MessagePayload>(
  response: AxiosResponse<T>,
): AxiosResponse<Omit<T, 'messages'> & { messages: Amity.ProcessedMessagePayload['messages'] }> => {
  return {
    ...response,
    data: {
      ...response.data,
      messages: response.data.messages.map(convertFromRaw),
    },
  };
};

type RawQueryMessages = Omit<Amity.QueryMessages, 'page' | 'sortBy' | 'subChannelId' | 'tags'> & {
  includeTags?: Amity.QueryMessages['tags'];
  messageFeedId: Amity.QueryMessages['subChannelId'];
  options: {
    sortBy?: Amity.QueryMessages['sortBy'];
    token: string;
  };
};

export function convertParams({
  subChannelId,
  mentionees,
  ...rest
}: Partial<Amity.Message>): Record<string, any> {
  return { messageFeedId: subChannelId, mentionedUsers: mentionees, ...rest };
}

export function convertQueryParams({
  page,
  sortBy,
  subChannelId,
  tags,
  ...rest
}: Amity.QueryMessages): RawQueryMessages {
  const out: RawQueryMessages = {
    ...rest,
    messageFeedId: subChannelId,
    options: { token: toToken(page || { limit: 10 }, 'afterbeforeraw')! },
  };

  if (sortBy !== undefined) {
    out.options.sortBy = sortBy;
  }

  if (tags) {
    out.includeTags = tags;
  }

  return out;
}

import axios from 'axios';
import HttpAgent, { HttpsAgent } from 'agentkeepalive';

import { ASCError } from '~/core/errors';

import { fireEvent } from '../events';
import { unwrapPayload } from './utils';

/**
 * Creates a pre-configured axios instance
 *
 * @param endpoint The ASC rest api server's URL
 * @returns A pre-configured axios instance
 *
 * @category Transport
 * @hidden
 */
export const createHttpTransport = (endpoint: string) => {
  const options = {
    maxSockets: 100,
    maxFreeSockets: 10,
    timeout: 60000,
    freeSocketTimeout: 30000,
  };

  const instance = axios.create({
    baseURL: endpoint,
    httpAgent: new HttpAgent(options),
    httpsAgent: new HttpsAgent(options),
    /*
     * If paramSerializer is required, use the serialize option to stringify
     * params. The encode option will pass complex params as string only whereas
     * the serialize option will pass params in the format Record<string, any>
     *
     * For more details:
     * https://github.com/axios/axios#request-config
     */
  });

  instance.interceptors.request.use(config => {
    // check global.ts for the extension of AxiosRequestConfig
    const tokenExpiry = config.metadata?.tokenExpiry;

    if (tokenExpiry) {
      if (Date.now() >= Date.parse(tokenExpiry)) {
        return {
          ...config,
          cancelToken: new axios.CancelToken(cancel => cancel('Token Expired')),
        };
      }
    }

    return config;
  });

  instance.interceptors.response.use(
    response => response,
    error => {
      const { response } = error;

      // handle unauthorized request
      if (response.data.code === Amity.ServerError.UNAUTHORIZED) {
        fireEvent('tokenTerminated', Amity.SessionStates.TERMINATED);
      }

      // handle request cancellation
      if (axios.isCancel(error)) {
        fireEvent('tokenExpired', Amity.SessionStates.TOKEN_EXPIRED);

        throw new ASCError(
          'Token expired',
          Amity.ClientError.TOKEN_EXPIRED,
          Amity.ErrorLevel.FATAL,
        );
      }

      // if it's an error with status in the response payload,
      // then it's an expected error.
      if (response?.data?.status) {
        unwrapPayload(response?.data);
      }
      // unexpected error.
      else {
        throw new Error(response?.data ?? error);
      }
    },
  );

  return instance;
};

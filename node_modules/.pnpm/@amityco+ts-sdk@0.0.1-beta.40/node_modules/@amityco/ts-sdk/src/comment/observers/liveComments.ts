/* eslint-disable no-use-before-define */
import { getResolver } from '~/core/model';
import { getActiveClient } from '~/client/api';
import { pushToCache, pullFromCache } from '~/cache/api';
import {
  createQuery,
  runQuery,
  queryOptions,
  filterByPropEquality,
  sortByFirstCreated,
  sortByLastCreated,
} from '~/core/query';

import {
  COLLECTION_DEFAULT_CACHING_POLICY,
  COLLECTION_DEFAULT_PAGINATION_LIMIT,
} from '~/utils/constants';

import {
  onCommentCreated,
  onCommentUpdated,
  onCommentDeleted,
  onCommentFlagged,
  onCommentUnflagged,
  onCommentReactionAdded,
  onCommentReactionRemoved,
} from '../events';
import { queryComments } from '../api';

/**
 * ```js
 * import { liveComments } from '@amityco/ts-sdk'
 *
 * let comments = []
 * const unsub = liveComments({
 *   referenceType: Amity.Comment['referenceType'];
 *   referenceId: Amity.Comment['referenceId'];
 * }, response => merge(comments, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Comment} for a given target object
 *
 * @param referenceType the type of the target
 * @param referenceId the ID of the target
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the messages
 *
 * @category Comments Live Collection
 */
export const liveComments = (
  params: Amity.CommentLiveCollection,
  callback: Amity.LiveCollectionCallback<Amity.Comment>,
  config?: Amity.LiveCollectionConfig,
): Amity.Unsubscriber => {
  const { log, cache } = getActiveClient();

  if (!cache) {
    console.log('For using Live Collection feature you need to enable Cache!');
  }

  const timestamp = Date.now();
  log(`liveComments(tmpid: ${timestamp}) > listen`);

  const { limit: queryLimit, ...queryParams } = params;

  const limit = queryLimit ?? COLLECTION_DEFAULT_PAGINATION_LIMIT;
  const { policy = COLLECTION_DEFAULT_CACHING_POLICY } = config ?? {};

  const disposers: Amity.Unsubscriber[] = [];
  const cacheKey = [
    'comment',
    'collection',
    { referenceId: params.referenceType, referenceType: params.referenceId },
  ];

  const responder = (data: Amity.CommentLiveCollectionCache) => {
    let comments: Amity.Comment[] =
      data.data
        .map(commentId => pullFromCache<Amity.Comment>(['comment', 'get', commentId])!)
        .filter(Boolean)
        .map(({ data }) => data) ?? [];

    comments = filterByPropEquality(comments, 'isDeleted', params.isDeleted);

    const sortBy = params.sortBy ? params.sortBy : 'lastCreated';

    comments = comments.sort(sortBy === 'lastCreated' ? sortByLastCreated : sortByFirstCreated);

    callback({
      onNextPage: onFetch,
      data: comments,
      hasNextPage: !!data.params?.page,
      loading: data.loading,
      error: data.error,
    });
  };

  const realtimeRouter = (action: Amity.CommentActionType) => (comment: Amity.Comment) => {
    const collection = pullFromCache<Amity.CommentLiveCollectionCache>(cacheKey)?.data;

    if (
      params.referenceId !== comment.referenceId ||
      params.referenceType !== comment.referenceType ||
      !collection
    )
      return;

    if (action === 'onCreate') {
      collection.data = [...new Set([comment.commentId, ...collection.data])];
    } else if (action === 'onDelete') {
      collection.data = collection.data.filter(p => p !== comment.commentId);
    }

    pushToCache(cacheKey, collection);

    responder(collection);
  };

  const onFetch = () => {
    const collection = pullFromCache<Amity.CommentLiveCollectionCache>(cacheKey)?.data;

    const comments = collection?.data ?? [];

    if (comments.length > 0 && !collection?.params?.page) return;

    const query = createQuery(queryComments, {
      ...queryParams,
      page: collection?.params?.page ?? { limit },
    });

    runQuery(
      query,
      ({ data: result, error, loading, prevPage, nextPage }) => {
        // depend on sortBy value we have two different pagination type
        const page = queryParams.sortBy ? nextPage : prevPage;

        const data = {
          loading,
          error,
          params: { page },
          data: comments,
        };

        if (result) {
          data.data = [...new Set([...comments, ...result.map(getResolver('comment'))])];
        }

        pushToCache(cacheKey, data);

        responder(data);
      },
      queryOptions(policy),
    );
  };

  disposers.push(
    onCommentCreated(realtimeRouter('onCreate')),
    onCommentUpdated(realtimeRouter('onUpdate')),
    onCommentDeleted(realtimeRouter('onDelete')),
    onCommentFlagged(realtimeRouter('onFlagged')),
    onCommentUnflagged(realtimeRouter('onUnflagged')),
    onCommentReactionAdded(realtimeRouter('onReactionAdded')),
    onCommentReactionRemoved(realtimeRouter('onReactionRemoved')),
  );

  onFetch();

  return () => {
    log(`liveComments(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};

import { client, generateRawMessage } from '~/utils/tests';
import { convertFromRaw } from '~/message/utils';
import {
  onMessageCreated,
  onMessageUpdated,
  onMessageDeleted,
  onMessageFlagged,
  onMessageUnflagged,
  onMessageFlagCleared,
  onMessageReactionAdded,
  onMessageReactionRemoved,
} from '../events';

describe('Message Events', () => {
  const rawMessage = generateRawMessage();
  const message = convertFromRaw(rawMessage);

  const cases: Array<
    [(callback: Amity.Listener<Amity.Message>) => Amity.Unsubscriber, keyof Amity.MqttMessageEvents]
  > = [
    [onMessageCreated, 'message.created'],
    [onMessageUpdated, 'message.updated'],
    [onMessageDeleted, 'message.deleted'],
    [onMessageFlagged, 'message.flagged'],
    [onMessageUnflagged, 'message.unflagged'],
    [onMessageFlagCleared, 'message.flagCleared'],
    [onMessageReactionAdded, 'message.reactionAdded'],
    [onMessageReactionRemoved, 'message.reactionRemoved'],
  ];

  cases.forEach(([onEvent, event]) => {
    test(`should call '${onEvent.name}' callback if '${event}' event is dispatched`, () => {
      const callback = jest.fn();
      const unsubscribe = onEvent(callback);
      client.emitter.emit(event, {
        messages: [rawMessage],
        files: [],
        users: [],
      });

      unsubscribe();

      expect(callback).toHaveBeenCalled();
      expect(callback).toHaveBeenCalledWith(message);
    });

    test(`should not call '${onEvent.name}' callback if we have already unsubscribed`, () => {
      const callback = jest.fn();
      const unsubscribe = onEvent(callback);

      unsubscribe();
      client.emitter.emit(event, {
        files: [],
        users: [],
        messages: [rawMessage],
      });

      expect(callback).not.toHaveBeenCalled();
    });
  });
});

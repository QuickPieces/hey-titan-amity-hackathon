/* eslint-disable no-param-reassign */
/* eslint-disable require-atomic-updates */
import { disconnectClient } from '~/client/api/disconnectClient';
import { getDeviceId } from '~/core/device';
import { proxyWebsocketEvents } from '~/core/events';
import {
  getUserTopic,
  getNetworkTopic,
  getSmartFeedChannelTopic,
  getSmartFeedMessageTopic,
  getSmartFeedSubChannelTopic,
  subscribeTopic,
} from '~/core/subscription';

import { onUserDeleted } from '~/user/events/onUserDeleted';

import { getActiveClient } from './activeClient';
import { terminateClient } from './terminateClient';
import { setActiveUser, getActiveUser } from './activeUser';

import { setSessionState } from './setSessionState';

import { onClientBanned } from '../events';
import { onTokenExpired } from '../events/onTokenExpired';
import { onTokenTerminated } from '../events/onTokenTerminated';

import { setClientToken } from '../utils/setClientToken';

/*
 * declared earlier to accomodate case when logging in with a different user
 * than the one already connected, in which case the existing subscriptions need
 * to be cleared
 */
const subscriptions: Amity.Unsubscriber[] = [];

/**
 * ```js
 * import { connectClient } from '@amityco/ts-sdk/client/api'
 * const success = await connectClient({
 *   userId: 'XYZ123456789',
 * })
 * ```
 *
 * Connects an {@link Amity.Client} instance to ASC servers
 *
 * @param params the connect parameters
 * @param params.userId the user ID for the current session
 * @param params.displayName the user's displayName for the current session
 * @param params.deviceId Manual override of the user's device id (for device management)
 * @param params.authToken The authentication token - necessary when network option is set to secure
 * @returns a success boolean if connected
 *
 * @category Client API
 * @async
 */
export const connectClient = async (
  params: Amity.ConnectClientParams,
  sessionHandler: Amity.SessionHandler,
  config?: Amity.ConnectClientConfig,
): Promise<boolean> => {
  const client = getActiveClient();
  let unsubWatcher: Amity.Unsubscriber;

  client.log('client/api/connectClient', {
    apiKey: client.apiKey,
    sessionState: client.sessionState,
    ...params,
  });

  // if connecting to a different userId than the one that is connected currently
  if (client.userId && client.userId !== params.userId) {
    await disconnectClient();

    // Remove subscription to ban and delete
    subscriptions.forEach(fn => fn());
  }

  // default values
  params.deviceId ??= getDeviceId();

  try {
    // @ts-ignore: in that particular case, typing can be
    // ignored since we enforce default values just before.
    const { users } = await setClientToken(params);

    // FIXME: events are duplicated if connectClient is called few times without disconnectClient
    // wire websocket events to our event emitter
    proxyWebsocketEvents(client.ws, client.emitter);

    // TODO: in phase 2, this should not be necessary. we should have WS
    // to be connected "on demand" rather than "by default"
    await new Promise(resolve => {
      client.ws.once('connect', resolve);
      client.ws.open();
    });

    client.userId = params.userId;

    client.sessionHandler = sessionHandler;

    /*
     * Cannot push to subscriptions as watcher needs to continue working even if
     * token expires
     */
    unsubWatcher = client.accessTokenExpiryWatcher(
      client.token?.issuedAt!,
      client.token?.expiresAt!,
      sessionHandler!,
    );

    setActiveUser(users[0]);
  } catch (error) {
    /*
     * if getting token failed session state reverts to initial state when app
     * is first launched
     */
    setSessionState(Amity.SessionStates.NOT_LOGGED_IN);

    // pass error down tree so the calling function handle it
    throw error;
  }

  if (config?.disableRTE !== true) {
    subscribeTopic(getNetworkTopic());
    subscribeTopic(getSmartFeedChannelTopic());
    subscribeTopic(getSmartFeedSubChannelTopic());
    subscribeTopic(getSmartFeedMessageTopic());
    // subscribing to user topic is necessary to handle ban event
    subscribeTopic(getUserTopic(getActiveUser()));
  }

  subscriptions.push(
    // GLOBAL_BAN
    onClientBanned((_: Amity.UserPayload) => {
      terminateClient();

      subscriptions.forEach(fn => fn());

      unsubWatcher();
    }),

    onTokenTerminated(_ => {
      terminateClient();

      subscriptions.forEach(fn => fn());

      unsubWatcher();
    }),

    onUserDeleted((user: Amity.User) => {
      if (user.userId === client.userId) {
        terminateClient();

        subscriptions.forEach(fn => fn());

        unsubWatcher();
      }
    }),

    onTokenExpired(state => {
      setSessionState(state);

      disconnectClient();

      subscriptions.forEach(fn => fn());
    }),
  );

  return client.ws.connected;
};

import { getActiveClient } from '~/client/api';

import { toPage, toToken } from '~/core/query';

import { pullFromCache, pushToCache } from '~/cache/api';
import { ingestInCache } from '~/cache/api/ingestInCache';
import { getResolver } from '~/core/model';
import { fireEvent } from '~/core/events';

/**
 * ```js
 * import { queryUsers } from '@amityco/ts-sdk'
 * const { data: users, prevPage, nextPage } = await queryUsers({ displayName: 'foo' })
 * ```
 *
 * Queries a paginable list of {@link Amity.User} objects
 * Search is performed by displayName such as `.startsWith(search)`
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.User} objects
 *
 * @category User API
 * @async
 */
export const queryUsers = async (
  query: Amity.QueryUsers = {},
): Promise<Amity.Cached<Amity.Paged<Amity.User>>> => {
  const client = getActiveClient();
  client.log('user/queryUsers', query);

  const {
    page = { limit: 10 },
    displayName,
    filter = 'all',
    sortBy = 'displayName',
    ...params
  } = query;

  const { data } = await client.http.get<Amity.UserPayload & Amity.Pagination>(`/api/v3/users`, {
    params: {
      ...params,
      keyword: displayName,
      filter,
      sortBy,
      options: {
        token: toToken(page, 'skiplimit'),
      },
    },
  });

  // unpacking
  const { paging, ...payload } = data;
  const { users } = payload;

  const cachedAt = client.cache && Date.now();

  if (client.cache) {
    ingestInCache(payload as Amity.UserPayload, { cachedAt });

    /*
     * using query as cache key over params because if the keyword, filter, sort
     * change the API will NOT cache results, when it should
     */
    const cacheKey = ['user', 'query', { ...query, options: { ...page } } as Amity.Serializable];
    pushToCache(cacheKey, { users: users.map(getResolver('user')), paging });
  }

  fireEvent('user.fetched', data);

  const prevPage = toPage(paging.previous);
  const nextPage = toPage(paging.next);

  return { data: users, cachedAt, prevPage, nextPage };
};

/**
 * ```js
 * import { queryUsers } from '@amityco/ts-sdk'
 * const { data: users } = queryUsers.locally({ keyword: 'foo' })
 * ```
 *
 * Queries a paginable list of {@link Amity.User} objects from cache
 * Search is performed by displayName such as `.startsWith(search)`
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.User} objects
 *
 * @category User API
 */
queryUsers.locally = (
  query: Parameters<typeof queryUsers>[0] = {},
): Amity.Cached<Amity.Paged<Amity.User>> | undefined => {
  const client = getActiveClient();
  client.log('user/queryUsers.locally', query);

  if (!client.cache) return;

  const { page = { limit: 10 } } = query ?? {};

  const cacheKey = [
    'user',
    'query',
    {
      ...query,
      options: { ...page },
    } as Amity.Serializable,
  ];

  const { data, cachedAt } =
    pullFromCache<{ users: Pick<Amity.User, 'userId'>[] } & Amity.Pagination>(cacheKey) ?? {};

  const users: Amity.User[] =
    data?.users
      .map(userId => pullFromCache<Amity.User>(['user', 'get', userId])!)
      .filter(Boolean)
      .map(({ data }) => data) ?? [];

  const prevPage = toPage(data?.paging.previous);
  const nextPage = toPage(data?.paging.next);

  return users.length > 0 && users.length === data?.users?.length
    ? { data: users, cachedAt, prevPage, nextPage }
    : undefined;
};

import { ASCApiError } from '~/core/errors';
import { disableCache, enableCache } from '~/cache/api';
import { ENABLE_CACHE_MESSAGE } from '~/utils/constants';
import {
  client,
  connectClient,
  disconnectClient,
  messages,
  generateRawMessage,
} from '~/utils/tests';

import { convertFromRaw } from '../../utils';
import { queryMessages } from '../../api';
import { liveMessages } from '../../observers';

describe('liveMessages', () => {
  beforeAll(async () => {
    await connectClient();
  });

  afterAll(async () => {
    await disconnectClient();
  });

  beforeEach(async () => {
    enableCache();
  });

  afterEach(disableCache);

  const { subChannelId } = messages;
  const returnValue = [{ messageId: messages.page1[0] }];
  const rawMessage = generateRawMessage({
    messageId: returnValue[0].messageId,
    messageFeedId: subChannelId,
  });
  const message = convertFromRaw(rawMessage);

  test('it should show message if cache not enabled', () => {
    /*
     * NOTE: at the time of writing this test cache is diabled by default, but
     * there is a proposal to enable cache by default. So I'm disabling cache
     * here to ensure cache is disabled
     */
    disableCache();

    const callback = jest.fn();
    jest.spyOn(global.console, 'log');
    client.http.get = jest.fn();

    // call liveMessages check if mocked console get's called with the correct
    // message
    client.use();
    liveMessages({ subChannelId }, callback);

    expect(console.log).toBeCalledWith(ENABLE_CACHE_MESSAGE);
  });

  test('it should return message collection', async () => {
    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ subChannelId }, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        data: [],
        error: undefined,
        loading: true,
      }),
    );

    await expect(queryMessages({ subChannelId })).resolves.toBeTruthy();

    expect(callback).toHaveBeenCalledTimes(2);

    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        // @ts-ignore
        data: returnValue.map(convertFromRaw),
        error: undefined,
        loading: false,
      }),
    );
  });

  test('it should return error on api failure', async () => {
    const error = new ASCApiError(
      'server error!',
      Amity.ServerError.ITEM_NOT_FOUND,
      Amity.ErrorLevel.ERROR,
    );

    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockRejectedValue(error);

    liveMessages({ subChannelId }, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        data: [],
        error: undefined,
        loading: true,
      }),
    );

    await expect(queryMessages({ subChannelId })).rejects.toThrow();

    expect(callback).toHaveBeenCalledTimes(2);

    expect(callback).toHaveBeenLastCalledWith(
      expect.objectContaining({
        error,
        data: [],
        loading: false,
      }),
    );
  });

  test('it should filter deleted messages based on param', async () => {
    // mock response of queryMessages with a deleted message
    const returnValue = [
      { messageId: messages.page1[0], isDeleted: true },
      { messageId: messages.page1[1], isDeleted: false },
    ];

    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ subChannelId, isDeleted: false }, callback);

    expect(callback).toHaveBeenCalledTimes(1);

    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        data: [],
        error: undefined,
        loading: true,
      }),
    );

    await expect(queryMessages({ subChannelId })).resolves.toBeTruthy();

    expect(callback).toHaveBeenCalledTimes(2);

    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        // @ts-ignore
        data: [returnValue[1]].map(convertFromRaw),
        error: undefined,
        loading: false,
      }),
    );
  });

  test('it should return method to fetch next page', async () => {
    const returnValue2 = [{ messageId: messages.page2[0] }];

    const callback = jest.fn();
    client.http.get = jest
      .fn()
      .mockResolvedValue({
        data: {
          messages: returnValue,
          paging: {
            previous: 'eyJsaW1pdCI6MiwiYmVmb3JlIjo2MzQ3MTYxNDM5MTExMTAwMDAwMH0',
            next: 'eyJsaW1pdCI6MiwiYmVmb3JlIjo2MzQ3MTYxNDM5MTExMTAwMDAwMH0',
          },
        },
      })
      .mockResolvedValueOnce({
        data: {
          messages: returnValue2,
          paging: {
            previous: 'eyJsaW1pdCI6MiwiYmVmb3JlIjo2MzQ3MTYxNDM5MTExMTAwMDAwMH0',
            next: 'eyJsaW1pdCI6MiwiYmVmb3JlIjo2MzQ3MTYxNDM5MTExMTAwMDAwMH0',
          },
        },
      });

    liveMessages({ subChannelId }, callback);

    expect(callback).toHaveBeenCalled();

    await expect(queryMessages({ subChannelId })).resolves.toBeTruthy();

    expect(callback.mock.lastCall).toHaveLength(1);

    const { onNextPage, hasNextPage } = callback.mock.lastCall[0];

    expect(hasNextPage).toBe(true);
    expect(onNextPage).toBeTruthy();

    onNextPage();

    await expect(queryMessages({ subChannelId })).resolves.toBeTruthy();

    // 4 -> becuase 1 local & server call each per call (2)
    expect(callback).toHaveBeenCalledTimes(4);

    expect(callback).toHaveBeenNthCalledWith(
      4,
      expect.objectContaining({
        // @ts-ignore
        data: [...returnValue2, ...returnValue].map(convertFromRaw),
        error: undefined,
        loading: false,
      }),
    );
  });

  test('it should add new message to collection onFetch', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ subChannelId }, callback);

    await expect(queryMessages({ subChannelId })).resolves.toBeTruthy();
    expect(callback).toHaveBeenCalledTimes(2);

    client.emitter.emit('local.message.fetched', { messages: [message] });

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining({
        data: [message],
        error: undefined,
        loading: false,
      }),
    );
  });

  test('it should add new message to collection onCreate', async () => {
    const rawNewMessage = generateRawMessage({
      messageId: 'new-message-id',
      messageFeedId: message.subChannelId,
    });
    const newMessage = convertFromRaw(rawNewMessage);

    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ subChannelId }, callback);

    await expect(queryMessages({ subChannelId })).resolves.toBeTruthy();
    expect(callback).toHaveBeenCalledTimes(2);

    // fire new message creation event
    client.emitter.emit('message.created', {
      messages: [rawNewMessage],
      users: [],
      files: [],
    });

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining({
        error: undefined,
        loading: false,
      }),
    );
    expect(callback.mock.calls[2][0].data[0]).toMatchObject(newMessage);
    expect(callback.mock.calls[2][0].data[1]).toMatchObject(returnValue[0]);
  });

  test('it should add new message to collection onUpdate', async () => {
    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ subChannelId }, callback);

    await expect(queryMessages({ subChannelId })).resolves.toBeTruthy();
    expect(callback).toHaveBeenCalledTimes(2);

    // fire new message creation event
    client.emitter.emit('message.updated', {
      messages: [rawMessage],
      users: [],
      files: [],
    });

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining({
        data: [message],
        error: undefined,
        loading: false,
      }),
    );
  });

  test('it should add new message to collection onDelete', async () => {
    // mock response of queryMessages and validate
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messages: returnValue,
        paging: {},
      },
    });

    liveMessages({ subChannelId }, callback);

    await expect(queryMessages({ subChannelId })).resolves.toBeTruthy();
    expect(callback).toHaveBeenCalledTimes(2);

    // fire new message creation event
    client.emitter.emit('message.deleted', {
      messages: [rawMessage],
      users: [],
      files: [],
    });

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining({
        data: [],
        error: undefined,
        loading: false,
      }),
    );
  });
});

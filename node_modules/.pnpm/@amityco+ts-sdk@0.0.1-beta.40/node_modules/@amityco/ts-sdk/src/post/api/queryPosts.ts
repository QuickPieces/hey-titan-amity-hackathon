import { getActiveClient } from '~/client/api';

import { toToken, toPageRaw } from '~/core/query';

import { pullFromCache, pushToCache } from '~/cache/api';
import { ingestInCache } from '~/cache/api/ingestInCache';
import { getResolver } from '~/core/model';
import { prepareMembershipPayload } from '~/group/utils';

/**
 * ```js
 * import { queryPosts } from '@amityco/ts-sdk'
 * const { data: posts, prevPage, nextPage } = await queryPosts({ targetId, targetType })
 * ```
 *
 * Queries a paginable list of {@link Amity.Post} objects
 *
 * @param query The query parameters
 * @returns posts
 *
 * @category Post API
 * @async
 */
export const queryPosts = async (
  query: Amity.QueryPosts,
): Promise<Amity.Cached<Amity.Paged<Amity.Post, Amity.PageRaw>>> => {
  const client = getActiveClient();
  client.log('post/queryPosts', query);

  const { page = { limit: 10 }, ...params } = query;
  const { dataTypes, matchingOnlyParentPost } = params;

  // API-FIX: parameters should be querystring. (1)
  // API-FIX: backend should answer Amity.Response (2)
  // const { data } = await client.http.get<Amity.Response<Amity.PagedResponse<Amity.PostPayload>>>(
  const { data } = await client.http.get<Amity.PostPayload & Amity.Pagination>(`/api/v4/posts`, {
    params: {
      ...params,
      /*
       * when creating post like image, file, video BE will create 2 posts
       * 1. parent post to store text with dataType=text
       * 2. child post to store dataTypes post data
       *
       * By default BE queries only parent post
       */
      matchingOnlyParentPost: matchingOnlyParentPost ?? !dataTypes?.length,
      options: {
        token: toToken(page, 'afterbeforeraw'),
      },
    },
  });

  // API-FIX: backend should answer Amity.Response (2)
  // const { paging, posts } = unwrapPayload(data)
  // unpacking
  const { paging, ...payload } = data;
  const paperedPayload = prepareMembershipPayload(payload, 'communityUsers');
  const { posts } = payload;

  const cachedAt = client.cache && Date.now();

  if (client.cache) {
    ingestInCache(paperedPayload, { cachedAt });

    const cacheKey = ['post', 'query', { ...params, options: { ...page } } as Amity.Serializable];
    pushToCache(cacheKey, { posts: posts.map(getResolver('post')), paging });
  }

  const nextPage = toPageRaw(paging.next);
  const prevPage = toPageRaw(paging.previous);

  return { data: posts, cachedAt, prevPage, nextPage };
};

/**
 * ```js
 * import { queryPosts } from '@amityco/ts-sdk'
 * const { data: posts, prevPage, nextPage } = queryPosts.locally({ targetId, targetType })
 * ```
 *
 * Queries a paginable list of {@link Amity.Post} objects from cache
 *
 * @param query The query parameters
 * @returns posts
 *
 * @category Post API
 */
queryPosts.locally = (
  query: Parameters<typeof queryPosts>[0],
): Amity.Cached<Amity.Paged<Amity.Post, Amity.PageRaw>> | undefined => {
  const client = getActiveClient();
  client.log('post/queryPosts.locally', query);

  if (!client.cache) return;

  const { page = { limit: 10 }, ...params } = query;

  const queryKey = ['post', 'query', { ...params, options: { ...page } } as Amity.Serializable];
  const { data, cachedAt } =
    pullFromCache<{ posts: Pick<Amity.Post, 'postId'>[] } & Amity.Pagination>(queryKey) ?? {};

  if (!data?.posts.length) return;

  const posts: Amity.Post[] = data.posts
    .map(postId => pullFromCache<Amity.Post>(['post', 'get', postId])!)
    .filter(Boolean)
    .map(({ data }) => data);

  const prevPage = toPageRaw(data?.paging.previous);
  const nextPage = toPageRaw(data?.paging.next);

  return posts.length === data?.posts?.length
    ? { data: posts, cachedAt, prevPage, nextPage }
    : undefined;
};

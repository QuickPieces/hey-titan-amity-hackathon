import { disableCache, enableCache, pushToCache } from '~/cache/api';
import {
  client,
  connectClient,
  disconnectClient,
  pause,
  generateRawSubChannel,
} from '~/utils/tests';
import { convertFromRaw } from '~/subChannel/utils';
import { getFutureDate, getPastDate } from '~/core/model';
import { liveSubChannels } from '../liveSubChannels';

describe('liveSubChannels', () => {
  const rawSubChannel = generateRawSubChannel();
  const response = {
    data: {
      messageFeeds: [rawSubChannel],
      paging: {},
    },
  };

  beforeAll(async () => {
    await connectClient();
  });

  afterAll(async () => {
    await disconnectClient();
  });

  beforeEach(enableCache);

  afterEach(disableCache);

  test('should get sub channels', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(response);

    liveSubChannels({ channelId: rawSubChannel.channelPublicId }, callback);
    await pause();

    expect(callback).toHaveBeenCalledTimes(2);
    expect(callback).toHaveBeenNthCalledWith(
      1,
      expect.objectContaining({
        data: [],
        loading: true,
      }),
    );
    expect(callback).toHaveBeenNthCalledWith(
      2,
      expect.objectContaining({
        data: [convertFromRaw(rawSubChannel)],
        loading: false,
      }),
    );
  });

  test('should filter deleted sub channels based on params', async () => {
    const rawSubChannels = [
      generateRawSubChannel({ isDeleted: true }),
      generateRawSubChannel({ messageFeedId: 'sub-channel-id-2' }),
    ];
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        messageFeeds: rawSubChannels,
        paging: {},
      },
    });

    liveSubChannels({ channelId: rawSubChannel.channelPublicId, isDeleted: false }, callback);
    await pause();

    expect(callback).toHaveBeenCalledTimes(2);
    expect(callback).toHaveBeenNthCalledWith(
      2,
      expect.objectContaining({
        data: [convertFromRaw(rawSubChannels[1])],
        loading: false,
      }),
    );
  });

  test('should fetch next page', async () => {
    const rawSubChannel2 = generateRawSubChannel({
      messageFeedId: 'sub-channel-id-2',
      lastMessageTimestamp: getPastDate(rawSubChannel.lastMessageTimestamp),
    });
    const callback = jest.fn();
    client.http.get = jest
      .fn()
      .mockResolvedValueOnce({
        data: {
          messageFeeds: [rawSubChannel],
          paging: {
            previous: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
            next: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
          },
        },
      })
      .mockResolvedValueOnce({
        data: {
          messageFeeds: [rawSubChannel2],
          paging: {
            previous: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
            next: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
          },
        },
      });

    liveSubChannels({ channelId: rawSubChannel.channelPublicId }, callback);
    await pause();
    callback.mock.lastCall[0].onNextPage();
    await pause();

    expect(callback).toHaveBeenCalledTimes(4);
    expect(callback).toHaveBeenNthCalledWith(
      2,
      expect.objectContaining({
        hasNextPage: true,
        onNextPage: expect.anything(),
      }),
    );
    expect(callback).toHaveBeenNthCalledWith(
      4,
      expect.objectContaining({
        data: [rawSubChannel, rawSubChannel2].map(convertFromRaw),
        loading: false,
      }),
    );
  });

  describe('events', () => {
    const newRawSubChannel = generateRawSubChannel({
      messageFeedId: 'sub-channel-id-2',
      lastMessageTimestamp: getFutureDate(rawSubChannel.lastMessageTimestamp),
    });
    const updatedRawSubChannel = {
      ...rawSubChannel,
      name: 'new name',
      updatedAt: getFutureDate(rawSubChannel.updatedAt),
    };
    const deletedRawSubChannel = {
      ...rawSubChannel,
      isDeleted: true,
      updatedAt: getFutureDate(rawSubChannel.updatedAt),
    };

    const cases: [string, keyof Amity.Events, Amity.RawSubChannel, Amity.SubChannel[]][] = [
      [
        'should add new sub channel to collection onCreate',
        'message-feed.created',
        newRawSubChannel,
        [newRawSubChannel, rawSubChannel].map(convertFromRaw),
      ],
      [
        'should remove sub channel from collection onDelete',
        'message-feed.deleted',
        deletedRawSubChannel,
        [],
      ],
      [
        'should update sub channel in collection onUpdate',
        'message-feed.updated',
        updatedRawSubChannel,
        [updatedRawSubChannel].map(convertFromRaw),
      ],
      [
        'should update sub channel in collection onFetch',
        'local.message-feed.fetched',
        updatedRawSubChannel,
        [updatedRawSubChannel].map(convertFromRaw),
      ],
    ];

    type testHandlerType = (...args: typeof cases[number]) => Promise<void>;
    const testHandler: testHandlerType = async (test, event, rawEventSubChannel, expected) => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue(response);

      liveSubChannels({ channelId: rawSubChannel.channelPublicId, isDeleted: false }, callback);
      await pause();
      if (event === 'local.message-feed.fetched') {
        pushToCache(
          ['subChannel', 'get', rawEventSubChannel.messageFeedId],
          convertFromRaw(rawEventSubChannel),
        );
        client.emitter.emit(event, { messageFeeds: [convertFromRaw(rawEventSubChannel)] });
      } else {
        client.emitter.emit(event, { messageFeeds: [rawEventSubChannel] });
      }
      await pause();

      expect(callback).toHaveBeenCalledTimes(3);
      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining({
          data: expected,
          loading: false,
        }),
      );
    };

    test.each(cases)('%s', testHandler);
  });
});

import { disableCache, enableCache } from '~/cache/api';
import {
  pause,
  client,
  connectClient,
  disconnectClient,
  generateRawSubChannel,
} from '~/utils/tests';
import { createQuery, runQuery } from '~/core/query';
import { deleteSubChannel, getSubChannel, updateSubChannel } from '~/subChannel/api';
import { getFutureDate } from '~/core/model';
import { liveSubChannel } from '../liveSubChannel';
import { convertFromRaw } from '../../utils';

describe('liveSubChannel', () => {
  const rawSubChannel = generateRawSubChannel();
  const subChannel = convertFromRaw(rawSubChannel);
  const response = { data: { messageFeeds: [rawSubChannel] } };

  beforeAll(async () => {
    await connectClient();
  });

  afterAll(async () => {
    await disconnectClient();
  });

  beforeEach(enableCache);

  afterEach(disableCache);

  const events: [string, keyof Amity.Events][] = [
    ['should get update on message-feed.updated event', 'message-feed.updated'],
    ['should get update on message-feed.deleted event', 'message-feed.deleted'],
  ];

  test.each(events)('%s', async (test, event) => {
    const update = {
      ...rawSubChannel,
      name: event,
      updatedAt: getFutureDate(rawSubChannel.updatedAt),
    };
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(response);

    liveSubChannel(subChannel.subChannelId, callback);
    await pause();
    client.emitter.emit(event, { messageFeeds: [update] });
    await pause();

    expect(callback).toHaveBeenCalledTimes(3);
    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining({
        data: convertFromRaw(update),
        loading: false,
      }),
    );
  });

  describe('should get an update without rte subscription', () => {
    const update = {
      ...rawSubChannel,
      name: 'new name',
      updatedAt: getFutureDate(rawSubChannel.updatedAt),
    };

    test('if getSubChannel is called', async () => {
      const callback = jest.fn();
      client.http.get = jest
        .fn()
        .mockResolvedValueOnce(response)
        .mockResolvedValueOnce({ data: { messageFeeds: [update] } });

      liveSubChannel(subChannel.subChannelId, callback);
      await pause();
      await getSubChannel(subChannel.subChannelId);
      await pause();

      expect(callback).toHaveBeenCalledTimes(3);
      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining({
          data: convertFromRaw(update),
          loading: false,
        }),
      );
    });

    test('if updateSubChannel is called', async () => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue(response);
      client.http.put = jest.fn().mockResolvedValue({ data: { messageFeeds: [update] } });

      liveSubChannel(subChannel.subChannelId, callback);
      await pause();
      await updateSubChannel(subChannel.subChannelId, { displayName: update.name });
      await pause();

      expect(callback).toHaveBeenCalledTimes(3);
      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining({
          data: convertFromRaw(update),
          loading: false,
        }),
      );
    });

    test('if deleteSubChannel is called', async () => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue(response);
      client.http.delete = jest.fn().mockResolvedValue({ data: { success: true } });

      liveSubChannel(subChannel.subChannelId, callback);
      await pause();
      runQuery(createQuery(deleteSubChannel, subChannel.subChannelId));
      await pause();

      expect(callback).toHaveBeenCalledTimes(3);
      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining({
          data: { ...subChannel, isDeleted: true, updatedAt: expect.anything() },
          loading: false,
        }),
      );
    });
  });
});

import { getActiveClient } from '~/client/api';

import { createQuery, runQuery, queryOptions } from '~/core/query';

import { getMessage } from '../api';

import { onMessageUpdated, onMessageDeleted } from '../events';

/**
 * ```js
 * import { observeMessage } from '@amityco/ts-sdk'
 *
 * let message = {}
 *
 * const unsub = observeMessage(messageId, updated => message = updated)
 * ```
 *
 * Observe all mutations on a {@link Amity.Message} given a single messageId
 *
 * @param client the client to observe the message with
 * @param messageId the ID of the message to observe
 * @param callback the function to call when new data are available
 * @param policy a query policy option for this observer
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the message
 *
 * @category Message Observer
 */
export const observeMessage = <Events extends ['onFetch', 'onUpdate', 'onDelete']>(
  messageId: Amity.Message['messageId'],
  callback: Amity.ObjectListener<Amity.Snapshot<Amity.Message>, Events>,
  policy: Amity.QueryPolicy = 'cache_then_server',
): Amity.Unsubscriber => {
  const { log } = getActiveClient();

  const timestamp = Date.now();
  log(`observeMessage(tmpid: ${timestamp}) > listen`);

  console.log(
    'observeMessage will be deprecated on 15th November 2022, please use liveMessage instead.',
  );

  // wrapper function to make sure
  const router = (result: Amity.Snapshot<Amity.Message>, action: Events[number]) => {
    // filter function
    if (result.data?.messageId !== messageId) return;

    if (callback instanceof Function) return callback(result);

    if (action !== 'onFetch') callback.onEvent?.(action, result);

    callback[action]?.(result);
  };

  const disposers: Amity.Unsubscriber[] = [];

  disposers.push(
    onMessageUpdated(data => router({ data, loading: false, origin: 'event' }, 'onUpdate')),
    onMessageDeleted(data => router({ data, loading: false, origin: 'event' }, 'onDelete')),
  );

  if (policy !== 'no_fetch') {
    runQuery(
      createQuery(getMessage, messageId),
      result => result.data && router(result, 'onFetch'),
      queryOptions(policy),
    );
  }

  return () => {
    log(`observeMessages(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};

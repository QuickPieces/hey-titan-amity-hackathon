import { getActiveClient } from '~/client/api';

import { onMessageCreated, onMessageUpdated, onMessageDeleted } from '../events';

/**
 * ```js
 * import { observeMessages } from '@amityco/ts-sdk'
 *
 * let messages = []
 *
 * const unsubscribe = observeMessages(channelId, message => merge(messages, message))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Message} for a given {@link Amity.SubChannel} object
 *
 * @param subChannelId the ID of the channel where to observe the messages
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the messages
 *
 * @category Message Observer
 */
export const observeMessages = (
  subChannelId: Amity.SubChannel['subChannelId'],
  callback: Amity.ObjectListener<
    Amity.Snapshot<Amity.Message>,
    ['onCreate', 'onUpdate', 'onDelete']
  >,
): Amity.Unsubscriber => {
  const { log } = getActiveClient();

  const timestamp = Date.now();
  log(`observeMessages(tmpid: ${timestamp}) > listen`);

  const disposers: Amity.Unsubscriber[] = [];

  const router = (
    message: Amity.Snapshot<Amity.Message>,
    action: 'onCreate' | 'onUpdate' | 'onDelete',
  ) => {
    if (message.data?.subChannelId !== subChannelId) return;

    if (callback instanceof Function) return callback(message);

    callback.onEvent?.(action, message);
    callback[action]?.(message);
  };

  disposers.push(
    onMessageCreated(data => router({ data, loading: false, origin: 'event' }, 'onCreate')),
    onMessageUpdated(data => router({ data, loading: false, origin: 'event' }, 'onUpdate')),
    onMessageDeleted(data => router({ data, loading: false, origin: 'event' }, 'onDelete')),
  );

  return () => {
    log(`observeMessages(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};

import { getActiveClient } from '~/client/api';
import { createQuery, runQuery, queryOptions } from '~/core/query';
import { getFollowInfo } from '../api';
import { onFollowInfoUpdated } from '../events';

/**
 * ```js
 * import { observeFollowInfo } from '@amityco/ts-sdk'
 *
 * let followInfo = {}
 * const dispose = observeFollowInfo(userId, updated => followInfo = updated)
 * ```
 *
 * Observe all mutation on a given {@link Amity.FollowInfo}
 *
 * @param userId the ID of the user to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the post
 *
 * @category Follow Observer
 */
export const observeFollowInfo = <Events extends ['onFetch', 'onUpdate']>(
  userId: Amity.User['userId'],
  callback: Amity.ObjectListener<Amity.Snapshot<Amity.FollowInfo>, Events>,
  policy: Amity.QueryPolicy = 'cache_then_server',
): Amity.Unsubscriber => {
  const { log } = getActiveClient();

  const timestamp = Date.now();
  log(`observeFollowInfo(tmpid: ${timestamp}) > listen`);

  const router = (result: Amity.Snapshot<Amity.FollowInfo>, action: Events[number]) => {
    if (callback instanceof Function) return callback(result);

    if (action !== 'onFetch') callback.onEvent?.(action, result);

    callback[action]?.(result);
  };

  const realtimeRouter = (result: Amity.Snapshot<Amity.FollowInfo>, action: Events[number]) => {
    if (result.data?.userId !== userId) return;

    router(result, action);
  };

  const disposers: Amity.Unsubscriber[] = [];

  disposers.push(
    onFollowInfoUpdated(data =>
      realtimeRouter({ data, loading: false, origin: 'event' }, 'onUpdate'),
    ),
  );

  runQuery(
    createQuery(getFollowInfo, userId),
    result => (result.data || result.error) && router(result, 'onFetch'),
    queryOptions(policy),
  );

  return () => {
    log(`observeFollowInfo(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};

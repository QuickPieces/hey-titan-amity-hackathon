import { getActiveClient } from '~/client/api';

import { toPage, toToken } from '~/core/query';
import { pullFromCache, pushToCache } from '~/cache/api';
import { ingestInCache } from '~/cache/api/ingestInCache';
import { getResolver } from '~/core/model';

/**
 * ```js
 * import { queryComments } from '@amityco/ts-sdk'
 * const comments = await queryComments({ referenceType: 'post', referenceId: 'foo' })
 * ```
 *
 * Queries a paginable list of {@link Amity.Comment} objects
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.Comment} objects
 *
 * @category Comment API
 * @async
 */
export const queryComments = async (
  query: Amity.QueryComments,
): Promise<Amity.Cached<Amity.Paged<Amity.Comment>>> => {
  const client = getActiveClient();
  client.log('comment/queryComments', query);

  const { page = { limit: 10 }, ...params } = query;

  const options = {
    type: params.sortBy ? 'pagination' : undefined,
    token: toToken(page, params.sortBy ? 'skiplimit' : 'afterbefore'),
  };
  // const filterByParentId = query.parentId !== undefined

  // API-FIX: parameters should be querystring. (1)
  // API-FIX: backend should answer Amity.Response (2)
  // const { data } = await client.http.get<Amity.Response<Amity.PagedResponse<Amity.CommentPayload>>>(
  const { data } = await client.http.get<Amity.CommentPayload & Amity.Pagination>(
    `/api/v3/comments`,
    {
      params: {
        ...params,
        //      filterByParentId, API-FIX: backend does not support this boolean LOL. what the hell seriously.
        options,
      },
    },
  );

  // API-FIX: backend should answer Amity.Response (2)
  // const { paging, comments } = unwrapPayload(data)
  const { paging, ...payload } = data;
  const { comments } = payload;

  const cachedAt = client.cache && Date.now();

  if (client.cache) {
    ingestInCache(payload as Amity.CommentPayload, { cachedAt });

    const cacheKey = [
      'comment',
      'query',
      { ...params, options: { ...page } } as Amity.Serializable,
    ];
    pushToCache(cacheKey, { comments: comments.map(getResolver('comment')), paging });
  }

  const nextPage = toPage(paging.next);
  const prevPage = toPage(paging.previous);

  return { data: comments, cachedAt, prevPage, nextPage };
};

/**
 * ```js
 * import { queryComments } from '@amityco/ts-sdk'
 * const comments = queryComments.locally({ referenceType: 'post', referenceId: 'foo' })
 * ```
 *
 * Queries a paginable list of {@link Amity.Comment} objects from cache
 *
 * @param query The query parameters
 * @returns comments
 *
 * @category Comment API
 */
queryComments.locally = (
  query: Parameters<typeof queryComments>[0],
): Amity.Cached<Amity.Paged<Amity.Comment>> | undefined => {
  const client = getActiveClient();
  client.log('comment/queryComments.locally', query);

  if (!client.cache) return;

  const { page = { limit: 10 }, ...params } = query;

  const queryKey = ['comment', 'query', { ...params, options: { ...page } } as Amity.Serializable];
  const { data, cachedAt } =
    pullFromCache<{ comments: Pick<Amity.Comment, 'commentId'>[] } & Amity.Pagination>(queryKey) ??
    {};

  if (!data?.comments.length) return;

  const comments: Amity.Comment[] = data.comments
    .map(commentId => pullFromCache<Amity.Comment>(['comment', 'get', commentId])!)
    .filter(Boolean)
    .map(({ data }) => data);

  const prevPage = toPage(data?.paging.previous);
  const nextPage = toPage(data?.paging.next);

  return comments.length === data?.comments?.length
    ? { data: comments, cachedAt, prevPage, nextPage }
    : undefined;
};

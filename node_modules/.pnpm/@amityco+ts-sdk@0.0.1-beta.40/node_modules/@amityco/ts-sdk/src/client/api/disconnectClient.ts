import { getActiveClient } from './activeClient';
import { setSessionState } from './setSessionState';

/**
 * ```js
 * import { disconnectClient } from '@amityco/ts-sdk'
 * const success = await disconnectClient()
 * ```
 *
 * Disconnects an {@link Amity.Client} instance from ASC servers
 *
 * @returns a success boolean if disconnected
 *
 * @category Client API
 * @async
 */
export const disconnectClient = async (): Promise<boolean> => {
  const client = getActiveClient();

  client.log('client/api/disconnectClient');

  await new Promise(resolve => {
    client.ws.once('disconnect', resolve);
    client.ws.disconnect();
    client.mqtt.disconnect();
  });

  client.emitter.all.clear();
  // FIXME: it removes listener in ws.ts, it breaks global ban event
  client.ws.removeAllListeners();
  client.mqtt.removeAllListeners();
  client.userId = undefined;
  client.token = undefined;

  client.http.defaults.headers.common.Authorization = '';
  client.ws.io.opts.query = { token: '' };

  /*
   * for cases when session state is terminated (example on ban) or token expired,
   * the terminating block will set session state to terminated or for the or
   * in the case of expired token the same happens
   *
   * establishing state also ignored in cases where accessTokenExpiryWatcher
   * calls renewal. There is a possibility that renewal will be called before
   * disconnectClient finishes execution
   */
  if (client.sessionState === Amity.SessionStates.ESTABLISHED)
    setSessionState(Amity.SessionStates.NOT_LOGGED_IN);

  /*
   * Cache should be usable if tokenExpired
   * https://ekoapp.atlassian.net/wiki/spaces/UP/pages/2082537485/ASC+Core+-+Session+Management+3.0#SDK-usability-based-on-Session-State
   */
  if (client.sessionState !== Amity.SessionStates.TOKEN_EXPIRED && client.cache) {
    client.cache = { data: {} };
  }

  return !client.ws.connected;
};

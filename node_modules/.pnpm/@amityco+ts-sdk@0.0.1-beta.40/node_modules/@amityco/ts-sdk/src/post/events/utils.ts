import { getActiveClient } from '~/client/api';
import { ingestInCache } from '~/cache/api/ingestInCache';
import { createEventSubscriber, fireEvent } from '~/core/events';
import { queryCache, upsertInCache, pullFromCache } from '~/cache/api';
import { prepareMembershipPayload } from '~/group/utils';

export const createPostEventSubscriber = (
  event: keyof Amity.MqttPostEvents,
  callback: Amity.Listener<Amity.Post>,
) => {
  const client = getActiveClient();

  const filter = (payload: Amity.PostPayload) => {
    if (!client.cache) {
      callback(payload.posts[0]);
    } else {
      const { communities, ...others } = payload;

      const data = prepareMembershipPayload(others, 'communityUsers');

      ingestInCache(data);

      if (communities?.[0] && !['post.updated'].includes(event)) {
        fireEvent('community.updated', {
          communities,
          categories: [],
          communityUsers: [],
          feeds: [],
          files: [],
          users: [],
        });
      }

      const post = pullFromCache<Amity.Post>(['post', 'get', payload.posts[0].postId])!;

      if (['post.created', 'post.approved', 'post.declined'].includes(event)) {
        let queries = queryCache(['post', 'query'])
          // @ts-ignore
          ?.filter(({ key }) => key[2]?.targetId === post.data.targetId);

        if (event === 'post.declined') {
          // @ts-ignore
          queries = queries?.filter(({ key }) => key[2]?.feedType === 'reviewing');
        }

        queries?.map(({ key, data }) => upsertInCache(key, data as any, { cachedAt: -1 }));
      }

      callback(post.data);
    }
  };

  return createEventSubscriber(client, event, event, filter);
};

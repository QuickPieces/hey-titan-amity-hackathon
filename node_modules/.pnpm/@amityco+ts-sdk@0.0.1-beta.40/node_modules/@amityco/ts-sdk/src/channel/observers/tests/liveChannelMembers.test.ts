import { disableCache, enableCache } from '~/cache/api';
import {
  bannedChannelUser,
  channel1,
  channelRaw1,
  channelUser,
  channelUser3,
  channelUserModel,
  channelUserQueryResponse,
  channelUserQueryResponsePage2,
  channelUserQueryResponsePage3,
  channelUserWithRole,
  client,
  connectClient,
  disconnectClient,
  emptyChannelUserQueryResponse,
  mutedChannelUser,
  pause,
  rawBannedChannelUser,
  rawChannelUser,
  rawChannelUserWithRole,
  user11,
  user13,
  user14,
} from '~/utils/tests';

import { liveChannelMembers } from '../liveChannelMembers';
import { prepareChannelPayload } from '../../utils';

const getSnapshot = (params?: Record<string, any>) => {
  return {
    data: [] as Amity.RawMembership<'channel'>[],
    loading: true,
    error: undefined as any,
    ...params,
  };
};

describe('liveChannelMembers', () => {
  beforeAll(async () => {
    await connectClient();
  });

  afterAll(async () => {
    await disconnectClient();
  });

  beforeEach(enableCache);

  afterEach(disableCache);

  const { channelId } = channel1;

  test('it should return channel members collection', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(channelUserQueryResponse);

    liveChannelMembers({ channelId }, callback);
    await pause();

    expect(callback).toHaveBeenNthCalledWith(1, expect.objectContaining(getSnapshot()));
    expect(callback).toHaveBeenNthCalledWith(
      2,
      expect.objectContaining(getSnapshot({ data: channelUserModel, loading: false })),
    );
  });

  const filters: [string, Amity.ChannelMembersLiveCollection, Amity.Membership<'channel'>[]][] = [
    [
      'roles',
      { channelId, roles: channelUserQueryResponsePage3.data.channelUsers[0].roles },
      [channelUserWithRole],
    ],
    ['searched term', { channelId, search: 'use' }, [channelUserWithRole, bannedChannelUser]],
    ['member', { channelId, memberships: ['member'] }, [channelUserWithRole, mutedChannelUser]],
    ['muted members', { channelId, memberships: ['muted'] }, [mutedChannelUser]],
    ['banned members', { channelId, memberships: ['banned'] }, [bannedChannelUser]],
    [
      'muted and banned members',
      { channelId, memberships: ['muted', 'banned'] },
      [mutedChannelUser, bannedChannelUser],
    ],
  ];

  test.each(filters)('it should filter channelUsers by %s', async (filter, params, expected) => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(channelUserQueryResponsePage3);

    liveChannelMembers(params, callback);
    await pause();

    expect(callback).toHaveBeenNthCalledWith(1, expect.objectContaining(getSnapshot()));
    expect(callback).toHaveBeenNthCalledWith(
      2,
      expect.objectContaining({ data: expected, loading: false }),
    );
  });

  test('it should return method to fetch next page', async () => {
    const callback = jest.fn();
    client.http.get = jest
      .fn()
      .mockResolvedValue(channelUserQueryResponse)
      .mockResolvedValueOnce(channelUserQueryResponsePage2);

    liveChannelMembers({ channelId }, callback);
    await pause();

    expect(callback).toHaveBeenCalled();
    expect(callback.mock.lastCall).toHaveLength(1);

    const { onNextPage, hasNextPage } = callback.mock.lastCall[0];

    expect(hasNextPage).toBe(true);
    expect(onNextPage).toBeTruthy();

    onNextPage();
    await pause();

    const payload = prepareChannelPayload(channelUserQueryResponse.data);
    const payload2 = prepareChannelPayload(channelUserQueryResponsePage2.data);

    const snapshot = getSnapshot();
    snapshot.loading = false;
    snapshot.data = [...payload2.channelUsers, ...payload.channelUsers];

    expect(callback).toHaveBeenNthCalledWith(4, expect.objectContaining(snapshot));
  });

  const events: [
    string,
    keyof Amity.Events,
    Amity.RawMembership<'channel'>,
    Amity.User,
    Amity.Membership<'channel'>[],
  ][] = [
    [
      'it should add new member to collection onMemberAdded',
      'channel.membersAdded',
      rawChannelUserWithRole,
      user14,
      [channelUserWithRole, channelUser, channelUser3],
    ],
    [
      'it should remove channel member from collection onMemberRemoved',
      'channel.membersRemoved',
      { ...rawChannelUser, membership: 'none' },
      user11,
      [channelUser3],
    ],
    [
      'it should update channel member membership on onChannelMemberBanned',
      'channel.banned',
      { ...rawChannelUser, membership: 'banned', isBanned: true },
      user11,
      [{ ...channelUser, membership: 'banned', isBanned: true }, channelUser3],
    ],
    [
      'it should update channel member membership on onChannelMemberUnbanned',
      'channel.unbanned',
      { ...rawChannelUser, membership: 'none', isBanned: false },
      user11,
      [channelUser3],
    ],
  ];

  test.each(events)('%s', async (test, event, channelUser, user, expected) => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(channelUserQueryResponse);

    liveChannelMembers({ channelId }, callback);
    await pause();

    client.emitter.emit(event, {
      channels: [channelRaw1],
      channelUsers: [channelUser],
      users: [user],
      files: [],
    });
    await pause();

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining(
        getSnapshot({
          data: expected,
          loading: false,
        }),
      ),
    );
  });

  it('should add the banned user to the collection if channel.banned event happens', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(emptyChannelUserQueryResponse);

    liveChannelMembers({ channelId, memberships: ['banned'] }, callback);
    await pause();
    client.emitter.emit('channel.banned', {
      channels: [channelRaw1],
      channelUsers: [rawBannedChannelUser],
      users: [user13],
      files: [],
    });
    await pause();

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining(getSnapshot({ data: [bannedChannelUser], loading: false })),
    );
  });
});

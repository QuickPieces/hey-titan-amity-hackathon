/* eslint-disable no-use-before-define */
import { getResolver } from '~/core/model';
import { getActiveClient } from '~/client/api';
import { pushToCache, pullFromCache } from '~/cache/api';
import { createQuery, runQuery, queryOptions } from '~/core/query';

import {
  COLLECTION_DEFAULT_CACHING_POLICY,
  COLLECTION_DEFAULT_PAGINATION_LIMIT,
} from '~/utils/constants';

import { onReactorAdded, onReactorRemoved } from '../events';
import { queryReactions } from '../api';

/**
 * ```js
 * import { liveReactions } from '@amityco/ts-sdk'
 *
 * let reactions = []
 * const unsub = liveReactions({
 *   referenceId: Amity.Reaction['referenceId'],
 *   referenceType: Amity.Reaction['referenceType'],
 * }, response => merge(reactions, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Reaction} for a given target object
 *
 * @param referenceType the type of the target
 * @param referenceId the ID of the target
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the messages
 *
 * @category Reactions Live Collection
 */
export const liveReactions = (
  params: Amity.ReactionLiveCollection,
  callback: Amity.LiveCollectionCallback<Amity.Reactor>,
  config?: Amity.LiveCollectionConfig,
): Amity.Unsubscriber => {
  const { log, cache } = getActiveClient();

  if (!cache) {
    console.log('For using Live Collection feature you need to enable Cache!');
  }

  const timestamp = Date.now();
  log(`liveReactions(tmpid: ${timestamp}) > listen`);

  const { limit: queryLimit, ...queryParams } = params;

  const limit = queryLimit ?? COLLECTION_DEFAULT_PAGINATION_LIMIT;
  const { policy = COLLECTION_DEFAULT_CACHING_POLICY } = config ?? {};

  const disposers: Amity.Unsubscriber[] = [];
  const cacheKey = [
    'reaction',
    'collection',
    { referenceId: params.referenceId, referenceType: params.referenceType },
  ];

  const responder = (data: Amity.ReactionLiveCollectionCache) => {
    const reactions: Amity.Reactor[] =
      data.data
        .map(reactorId => pullFromCache<Amity.Reactor>(['reaction', 'get', reactorId])!)
        .filter(Boolean)
        .map(({ data }) => data) ?? [];

    callback({
      onNextPage: onFetch,
      data: reactions,
      hasNextPage: !!data.params?.page,
      loading: data.loading,
      error: data.error,
    });
  };

  const realtimeRouter = (action: Amity.ReactionActionType) => (reaction: Amity.Reactor) => {
    const collection = pullFromCache<Amity.ReactionLiveCollectionCache>(cacheKey)?.data;
    if (!collection) return;

    if (action === 'onAdded') {
      collection.data = [...new Set([reaction.reactionId, ...collection.data])];
    } else if (action === 'onRemoved') {
      collection.data = collection.data.filter(p => p !== reaction.reactionId);
    }

    pushToCache(cacheKey, collection);
    responder(collection);
  };

  const onFetch = () => {
    const collection = pullFromCache<Amity.ReactionLiveCollectionCache>(cacheKey)?.data;

    const reactions = collection?.data ?? [];

    if (reactions.length > 0 && !collection?.params?.page) return;

    const query = createQuery(queryReactions, {
      ...queryParams,
      page: collection?.params?.page ?? { limit },
    });

    runQuery(
      query,
      ({ data: result, error, loading, nextPage: page }) => {
        const data = {
          loading,
          error,
          params: { page },
          data: reactions,
        };

        if (result) {
          data.data = [
            ...new Set([...reactions, ...result[0].reactors.map(getResolver('reaction'))]),
          ];
        }

        pushToCache(cacheKey, data);

        responder(data);
      },
      queryOptions(policy),
    );
  };

  disposers.push(
    onReactorAdded(queryParams.referenceType, queryParams.referenceId, realtimeRouter('onAdded')),
    onReactorRemoved(
      queryParams.referenceType,
      queryParams.referenceId,
      realtimeRouter('onRemoved'),
    ),
  );

  onFetch();

  return () => {
    log(`liveReactions(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};

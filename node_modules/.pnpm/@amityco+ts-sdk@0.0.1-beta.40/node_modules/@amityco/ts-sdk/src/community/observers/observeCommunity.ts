import { createQuery, runQuery } from '~/core/query/query';

import { getActiveClient } from '~/client/api';

import { getCommunity } from '../api';

import {
  onCommunityUpdated,
  onCommunityDeleted,
  onCommunityJoined,
  onCommunityLeft,
  onCommunityUserAdded,
  onCommunityUserRemoved,
  onCommunityUserBanned,
  onCommunityUserUnbanned,
} from '../events';

/**
 * ```js
 * import { observeCommunity } from '@amityco/ts-sdk'
 *
 * let community = {}
 * const dispose = observeCommunity(communityId, updated => community = updated)
 * ```
 *
 * Observe all mutation on a given {@link Amity.Community}
 *
 * @param communityId the ID of the community to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the community
 *
 * @category Community Observer
 */
export const observeCommunity = <
  Events extends [
    'onFetch',
    'onUpdate',
    'onDelete',
    'onJoin',
    'onLeft',
    'onUserAdded',
    'onUserRemoved',
    'onUserBanned',
    'onUserUnbanned',
  ],
>(
  communityId: string,
  callback: Amity.ObjectListener<Amity.Snapshot<Amity.Community | undefined>, Events>,
): Amity.Unsubscriber => {
  const { log } = getActiveClient();

  const timestamp = Date.now();
  log(`observeCommunity(tmpid: ${timestamp}) > listen`);

  // wrapper function to make sure
  const router = (result: Amity.Snapshot<Amity.Community | undefined>, action: Events[number]) => {
    if (callback instanceof Function) return callback(result);

    if (action !== 'onFetch') callback.onEvent?.(action, result);

    callback[action]?.(result);
  };

  const realtimeRouter = (result: Amity.Snapshot<Amity.Community>, action: Events[number]) => {
    if (result.data?.communityId !== communityId) return;

    router(result, action);
  };

  const disposers: Amity.Unsubscriber[] = [];

  disposers.push(
    onCommunityUpdated(data =>
      realtimeRouter({ data, loading: false, origin: 'event' }, 'onUpdate'),
    ),
    onCommunityDeleted(data =>
      realtimeRouter({ data, loading: false, origin: 'event' }, 'onDelete'),
    ),
    onCommunityJoined(data => realtimeRouter({ data, loading: false, origin: 'event' }, 'onJoin')),
    onCommunityLeft(data => realtimeRouter({ data, loading: false, origin: 'event' }, 'onLeft')),
    onCommunityUserAdded(data =>
      realtimeRouter({ data, loading: false, origin: 'event' }, 'onUserAdded'),
    ),
    onCommunityUserRemoved(data =>
      realtimeRouter({ data, loading: false, origin: 'event' }, 'onUserRemoved'),
    ),
    onCommunityUserBanned(data =>
      realtimeRouter({ data, loading: false, origin: 'event' }, 'onUserBanned'),
    ),
    onCommunityUserUnbanned(data =>
      realtimeRouter({ data, loading: false, origin: 'event' }, 'onUserUnbanned'),
    ),
  );

  runQuery(
    createQuery(getCommunity, communityId),
    result => (result.data || result.error) && router(result, 'onFetch'),
  );

  return () => {
    log(`observeCommunity(tmpid: ${timestamp}) > dispose`);
    disposers.forEach(fn => fn());
  };
};

import { disableCache, enableCache, pullFromCache } from '~/cache/api';
import {
  client,
  connectClient,
  disconnectClient,
  flaggedUser as unflaggedUser,
  flaggedUserQueryResponse as unflaggedUserQueryResponse,
} from '~/utils/tests';
import { ASCApiError } from '~/core/errors';

import { onUserUnflagged } from '~/user/events';

import { deleteReport } from '..';
import REFERENCE_TYPES from '../../constants/referenceTypes';

describe('deleteReport', () => {
  beforeAll(connectClient);
  afterAll(disconnectClient);

  // integration_test_id: fddf1d63-98e2-4296-ab3a-4e2b55044f89
  test('it should unflag user with userId', async () => {
    const expected = true;
    client.http.delete = jest.fn().mockResolvedValue(unflaggedUserQueryResponse);

    const received = await deleteReport('user', unflaggedUser.userId);

    expect(received).toBe(expected);
  });

  // integration_test_id: a95a0784-56ce-4b17-ac1b-0f1c50a361ef
  test('it should throw error with 400400 when sending invalid userId', async () => {
    client.http.delete = jest
      .fn()
      .mockRejectedValueOnce(
        new ASCApiError('unauthorized', Amity.ServerError.ITEM_NOT_FOUND, Amity.ErrorLevel.ERROR),
      );

    await expect(deleteReport('user', unflaggedUser.userId)).rejects.toThrow('400400');
  });

  test('it should fire event for user', async () => {
    let dispose;
    const expected = unflaggedUser;

    client.http.delete = jest.fn().mockResolvedValue(unflaggedUserQueryResponse);

    const callbackPromise = new Promise(resolve => {
      dispose = onUserUnflagged(resolve);
    }).finally(dispose);

    const recieved = await deleteReport('user', unflaggedUser.userId);

    expect(recieved).toBe(true);
    await expect(callbackPromise).resolves.toEqual(expect.objectContaining(expected));
  });

  test.todo('it should fire event for unflagging message');
  test.todo('it should fire event for unflagging delete');

  const tests: [keyof typeof REFERENCE_TYPES, string, string][] = [
    ['user', 'userId', `/api/v4/me/flags/${encodeURIComponent('userId')}`],
    ['post', 'postId', `/api/v3/posts/${encodeURIComponent('postId')}/unflag`],
    ['message', 'messageId', `/api/v5/messages/${encodeURIComponent('messageId')}/flags`],
  ];

  test.each(tests)(
    'it should call the appropriate api for %s',
    async (referenceType, referenceId, expected) => {
      const apimock = jest.fn();

      client.http.delete = apimock.mockResolvedValue({ data: {} });

      await deleteReport(referenceType, referenceId);

      const received = apimock.mock.lastCall[0];

      expect(received).toBe(expected);
    },
  );

  test('it should add data to cache', async () => {
    enableCache();
    const expected = unflaggedUser;
    client.http.delete = jest.fn().mockResolvedValue(unflaggedUserQueryResponse);

    await deleteReport('user', unflaggedUser.userId);
    const recieved = pullFromCache(['user', 'get', unflaggedUser.userId]);

    expect(recieved?.data).toBe(expected);

    disableCache();
  });
});

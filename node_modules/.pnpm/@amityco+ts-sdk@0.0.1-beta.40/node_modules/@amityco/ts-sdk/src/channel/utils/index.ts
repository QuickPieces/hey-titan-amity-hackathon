import { pullFromCache } from '~/cache/api';
import { withUsers } from '~/group/utils';

export function convertFromRaw(
  { _id, ...rest }: Amity.RawChannel,
  params: Pick<
    Amity.Channel,
    | 'defaultSubChannelHasUnreadMention'
    | 'defaultSubChannelUnreadCount'
    | 'localLastMentionSegment'
    | 'localReadToSegment'
  >,
): Amity.Channel {
  return {
    ...rest,
    ...params,
    defaultSubChannelId: _id,
  };
}

function getSegmentParams(rawChannel: Amity.RawChannel) {
  let cached;

  try {
    cached = pullFromCache<Amity.Channel>(['channel', 'get', rawChannel.channelId]);
    // eslint-disable-next-line no-empty
  } catch {}

  if (cached) {
    return {
      defaultSubChannelHasUnreadMention: cached.data.defaultSubChannelHasUnreadMention,
      defaultSubChannelUnreadCount: cached.data.defaultSubChannelUnreadCount,
      localReadToSegment: cached.data.localReadToSegment,
      localLastMentionSegment: cached.data.localLastMentionSegment,
    };
  }

  return {
    defaultSubChannelHasUnreadMention: false,
    defaultSubChannelUnreadCount: 0,
    // @ts-ignore
    localReadToSegment: rawChannel.messageCount > 0 ? rawChannel.messageCount - 1 : 0,
    localLastMentionSegment: 0,
  };
}

export const prepareChannelPayload = (
  rawPayload: Amity.ChannelPayload,
): Amity.ProcessedChannelPayload => {
  const channels: Amity.Channel[] = rawPayload.channels.map(channel =>
    convertFromRaw(channel, getSegmentParams(channel)),
  );

  const channelUsers: Amity.Membership<'channel'>[] = withUsers(rawPayload.channelUsers);

  return { ...rawPayload, channels, channelUsers };
};

import { uuid } from '~/core/uuid';
import { fireEvent } from '~/core/events';
import { getActiveClient } from '~/client/api';
import { ingestInCache } from '~/cache/api/ingestInCache';
import { UNSYNCED_OBJECT_CACHED_AT_VALUE } from '~/utils/constants';
import { upsertInCache, pullFromCache, pushToCache, dropFromCache } from '~/cache/api';

import { convertParams, prepareMessagePayload } from '../utils';

// FIXME: temp solution
let uniqueId: string | undefined;

/**
 * ```js
 * import { createMessage, createQuery, runQuery } from '@amityco/ts-sdk'
 *
 * const query = createQuery(createMessage, {
 *   subChannelId: 'foobar',
 *   data: { text: 'hello world' },
 * });
 *
 * runQuery(query, ({ data: message, loading }) => {
 *   console.log(message);
 * });
 * ```
 *
 * Creates an {@link Amity.Message}
 *
 * @param bundle The data necessary to create a new {@link Amity.Message}
 * @returns The newly created {@link Amity.Message}
 *
 * @category Message API
 * @async
 */
export const createMessage = async <T extends Amity.MessageContentType>(
  bundle: Pick<
    Amity.Message<T>,
    'subChannelId' | 'parentId' | 'dataType' | 'tags' | 'metadata' | 'mentionees'
  > & {
    data?: Amity.Message<T>['data'];
    fileId?: Amity.File['fileId'];
  },
): Promise<Amity.Cached<Amity.Message>> => {
  const client = getActiveClient();
  client.log('message/createMessage', bundle);

  const referenceId = uniqueId;
  uniqueId = undefined;

  const { data: payload } = await client.http.post<Amity.MessagePayload>('/api/v5/messages', {
    ...convertParams(bundle),
    referenceId,
  });

  const data = prepareMessagePayload(payload);
  const { messages } = data;

  const cachedAt = client.cache && Date.now();
  if (client.cache) {
    dropFromCache(['message', 'get', referenceId]);
    ingestInCache(data, { cachedAt });
  }

  fireEvent('local.message.created', { messages });

  return {
    data: messages[0],
    cachedAt,
  };
};

/**
 * ```js
 * import { createMessage } from '@amityco/ts-sdk'
 *
 * const created = createMessage.optimistically({
 *   channelId: 'foobar',
 *   data: { text: 'hello world' }
 * })
 * ```
 *
 * Creates an {@link Amity.Message} in cache
 *
 * @param bundle The data necessary to create a new {@link Amity.Message}
 * @returns The newly created {@link Amity.Message}
 *
 * @category Message API
 */
createMessage.optimistically = (
  bundle: Parameters<typeof createMessage>[0],
): Amity.Cached<Amity.Message> | undefined => {
  const client = getActiveClient();

  if (!client.cache) return;

  /*
   * when creating messages optimistically a messageId needs to be added by the
   * client, created a new variable so as to allow backward compatibility of API
   *
   * Updated to handle client requirement to add messageId while uploading
   * message with image. Temporary!
   */
  const localId = `LOCAL_${uuid()}`;
  uniqueId = localId;
  const bundleWithMessageId = { messageId: localId, uniqueId: localId, ...bundle };

  client.log('message/createMessage.optimistically', bundleWithMessageId);

  const subChannel = pullFromCache<Amity.SubChannel>(['subChannel', 'get', bundle.subChannelId]);

  if (subChannel) {
    upsertInCache(['subChannel', 'get', bundle.subChannelId], {
      ...subChannel.data,
      messageCount: subChannel.data.messageCount + 1,
    });

    if (subChannel.data.channelId === subChannel.data.subChannelId) {
      const channel = pullFromCache<Amity.Channel>(['channel', 'get', subChannel.data.channelId]);

      if (channel?.data) {
        upsertInCache(['channel', 'get', subChannel.data.channelId], {
          ...channel.data,
          messageCount: (channel.data.messageCount ?? 0) + 1,
        });
      }
    }
  }

  // as reused to update created and updated time, which should be the same
  const createdTime = new Date().toISOString();

  const message = {
    creatorId: client.userId!,
    channelSegment: (subChannel?.data.messageCount ?? 0) + 1,
    childrenNumber: 0,
    createdAt: createdTime,
    updatedAt: createdTime,
    ...bundleWithMessageId,
  } as Amity.Message;

  const cachedAt = UNSYNCED_OBJECT_CACHED_AT_VALUE;

  pushToCache(['message', 'get', message.messageId], message, { cachedAt });
  fireEvent('local.message.created', { messages: [message] });

  return {
    cachedAt,
    data: message,
  };
};

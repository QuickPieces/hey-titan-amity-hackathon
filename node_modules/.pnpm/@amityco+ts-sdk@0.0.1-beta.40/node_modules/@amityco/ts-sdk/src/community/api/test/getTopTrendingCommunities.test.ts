import { disableCache, enableCache, pullFromCache, pushToCache } from '~/cache/api';
import { client, community11, community21 } from '~/utils/tests';

import { getTopTrendingCommunities } from '../getTopTrendingCommunities';

const topTrendCommunities = [community11, community21];
const topTrendIds = topTrendCommunities.map(({ communityId }) => communityId);

const pagingToken = {
  previous: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
  next: 'eyJiZWZvcmUiOjU1LCJsYXN0IjoxMH0=',
};

const pagingCriteria = { limit: 10 };

const resolvedGetValue = {
  data: {
    communities: topTrendCommunities,
    communityUsers: [community11, community21],
    files: [],
    users: [],
    categories: [],
    feeds: [],
    paging: pagingToken,
  },
};

describe('getTopTrendingCommunities', () => {
  test('should return fetched top trend communities with correct paging', async () => {
    client.http.get = jest.fn().mockResolvedValueOnce(resolvedGetValue);

    await expect(getTopTrendingCommunities(pagingCriteria)).resolves.toEqual(
      expect.objectContaining({ data: topTrendCommunities }),
    );
  });

  test('should update cache after fetching top trend communities', async () => {
    enableCache();
    client.http.get = jest.fn().mockResolvedValue(resolvedGetValue);

    await getTopTrendingCommunities(pagingCriteria);

    const recieved = pullFromCache([
      'community',
      'top-trending',
      { params: { options: pagingCriteria } },
    ])?.data;

    expect(recieved).toEqual({ communities: topTrendIds });

    disableCache();
  });

  test('should throw an error if request fails', async () => {
    client.http.get = jest.fn().mockRejectedValueOnce(new Error('error'));

    await expect(getTopTrendingCommunities(pagingCriteria)).rejects.toThrow('error');
  });
});

describe('getTopTrendingCommunities.locally', () => {
  beforeEach(() => enableCache());
  afterEach(() => disableCache());

  test('should return cached top trend communities', () => {
    topTrendCommunities.forEach(community =>
      pushToCache(['community', 'get', community.communityId], community),
    );

    pushToCache(['community', 'top-trending', { params: { options: pagingCriteria } }], {
      communities: topTrendIds,
    });

    expect(getTopTrendingCommunities.locally(pagingCriteria)?.data).toEqual(topTrendCommunities);
  });

  test('it should return undefined if top trend communities not in cache', () => {
    topTrendCommunities.forEach(community =>
      pushToCache(['community', 'get', community.communityId], community),
    );

    pushToCache(['community', 'top-trending', { params: { options: pagingCriteria } }], {
      communities: topTrendIds,
    });

    expect(getTopTrendingCommunities.locally({ limit: -1 })).toBeUndefined();
  });

  test('should return undefined if cache not enabled', () => {
    disableCache();

    topTrendCommunities.forEach(community =>
      pushToCache(['community', 'get', community.communityId], community),
    );

    pushToCache(['community', 'top-trending', { params: { options: pagingCriteria } }], {
      communities: topTrendIds,
    });

    expect(getTopTrendingCommunities.locally(pagingCriteria)).toBeUndefined();
  });
});

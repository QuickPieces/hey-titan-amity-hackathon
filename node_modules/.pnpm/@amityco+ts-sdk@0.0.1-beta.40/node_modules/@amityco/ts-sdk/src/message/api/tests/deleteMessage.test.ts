import { disableCache, enableCache, pullFromCache, pushToCache } from '~/cache/api';
import { client, generateRawMessage } from '~/utils/tests';

import { deleteMessage } from '../deleteMessage';
import { onMessageDeleted } from '../../events';
import { convertFromRaw } from '../../utils';

const rawMessageToDelete = generateRawMessage();
const messageToDelete = convertFromRaw(rawMessageToDelete);
const { messageId: deleteId } = messageToDelete;
const rawDeletedMessage = { ...rawMessageToDelete, isDeleted: true };
const deletedMessage = convertFromRaw(rawDeletedMessage);

const getResolvedMessageValue = () => ({
  data: {
    messages: [rawDeletedMessage],
    users: [],
    files: [],
  },
});

describe('deleteMessage', () => {
  test('should return deleted message', async () => {
    client.http.delete = jest.fn();
    client.http.get = jest.fn().mockResolvedValueOnce(getResolvedMessageValue());

    await expect(deleteMessage(deleteId)).resolves.toEqual(deletedMessage);
  });

  test('should throw an error if request fails', async () => {
    client.http.delete = jest.fn().mockRejectedValueOnce(new Error('error'));

    await expect(deleteMessage(deleteId)).rejects.toThrow('error');
  });

  test('should update cache after deleted messages', async () => {
    enableCache();
    client.http.delete = jest.fn();
    client.http.get = jest.fn().mockResolvedValueOnce(getResolvedMessageValue());
    pushToCache(['message', 'get', deleteId], messageToDelete);

    await deleteMessage(deleteId);
    const recieved = pullFromCache<Amity.Message>(['message', 'get', deleteId])?.data;

    expect(recieved).toEqual(deletedMessage);

    disableCache();
  });

  test('should fire event `onMessageDeleted`', async () => {
    let dispose;
    client.http.delete = jest.fn();
    client.http.get = jest.fn().mockResolvedValueOnce(getResolvedMessageValue());

    const callbackPromise = new Promise(resolve => {
      dispose = onMessageDeleted(resolve);
    }).finally(dispose);

    await deleteMessage(deleteId);

    await expect(callbackPromise).resolves.toEqual(deletedMessage);
  });
});

describe('deleteMessage.optimistically', () => {
  beforeEach(() => enableCache());
  afterEach(() => disableCache());

  test('should update `isDeleted` in cache after deleted message', () => {
    pushToCache(['message', 'get', deleteId], messageToDelete);

    deleteMessage.optimistically(deleteId);
    const recieved = pullFromCache<Amity.Message>(['message', 'get', deleteId])?.data;

    expect(recieved).toEqual({
      ...deletedMessage,
      updatedAt: expect.anything(),
    });
  });

  /* TODO: re-enable this after fixed channel message count calculation */
  test.skip('should decrease message count after deleted message', () => {
    const { channelId } = messageToDelete;
    pushToCache(['channel', 'get', channelId], { channelId, messageCount: 2 });
    pushToCache(['message', 'get', deleteId], { ...messageToDelete, channelId });

    deleteMessage.optimistically(deleteId);
    const recieved = pullFromCache<Amity.Channel>(['channel', 'get', channelId])?.data;

    expect(recieved?.messageCount).toBe(1);
  });

  test('should fire event `onMessageDeleted`', async () => {
    pushToCache(['message', 'get', deleteId], messageToDelete);
    let dispose;

    const callbackPromise = new Promise(resolve => {
      dispose = onMessageDeleted(data => {
        resolve(data);
      });
    }).finally(dispose);

    await deleteMessage.optimistically(deleteId);

    await expect(callbackPromise).resolves.toEqual({
      ...deletedMessage,
      updatedAt: expect.anything(),
    });
  });

  test('should define object as unsynced object', () => {
    pushToCache(['message', 'get', deleteId], messageToDelete);

    expect(deleteMessage.optimistically(deleteId)?.cachedAt).toBe(-1);
  });
});

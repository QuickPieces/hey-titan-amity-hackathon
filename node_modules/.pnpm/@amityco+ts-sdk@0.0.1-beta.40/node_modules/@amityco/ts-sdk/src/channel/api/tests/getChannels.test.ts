import { disableCache, enableCache, pushToCache, pullFromCache } from '~/cache/api';
import { client, getChannelsResponse } from '~/utils/tests';

import { getChannels } from '../getChannels';
import { prepareChannelPayload } from '~/channel/utils';
import { ASCApiError } from '~/core/errors';

const channelIds = [
  getChannelsResponse.data.channels[0].channelId,
  getChannelsResponse.data.channels[1].channelId,
  getChannelsResponse.data.channels[2].channelId,
];
const channel = prepareChannelPayload(getChannelsResponse.data).channels;

describe('getChannels', () => {
  // integration_test_id: ced0cd3b-1714-499d-862e-0284da1c8bb1
  test('it should return a valid channels', async () => {
    client.http.get = jest.fn().mockResolvedValueOnce(getChannelsResponse);

    const expected = channel;
    const { data: received } = await getChannels(channelIds);

    expect(received).toStrictEqual(expected);
  });

  test('it should update cache after fetch from server', async () => {
    enableCache();
    client.http.get = jest.fn().mockResolvedValue(getChannelsResponse);
    await getChannels(channelIds);

    const data = getChannels.locally(channelIds);

    expect(data).toBeDefined();
    expect(data?.data).toEqual(channel);

    disableCache();
  });

  // integration_test_id: 344a8f3d-0e54-4eb9-850f-80283e638352
  test('it should return an error 400400 when try to get channels by invalid channel id', async () => {
    const error = new ASCApiError(
      'Some channel not found',
      Amity.ServerError.ITEM_NOT_FOUND,
      Amity.ErrorLevel.ERROR,
    );

    client.http.get = jest.fn().mockRejectedValueOnce(error);

    await expect(getChannels(channelIds)).rejects.toThrow(error);
  });
});

describe('getChannels locally', () => {
  test('it should return data from cache', () => {
    enableCache();

    const cachedAt = Date.now();

    pushToCache(['channel', 'get', channelIds[0]], channel[0], { cachedAt });
    pushToCache(['channel', 'get', channelIds[1]], channel[1], { cachedAt });
    pushToCache(['channel', 'get', channelIds[2]], channel[2], { cachedAt });

    const data = getChannels.locally(channelIds);

    expect(data).toBeDefined();
    expect(data?.data).toEqual(channel);
    expect(data?.cachedAt).toEqual(cachedAt);

    disableCache();
  });

  test('should return undefined if channel not in cache', () => {
    expect(
      getChannels.locally(['non-existent-channel-1', 'non-existent-channel-2']),
    ).toBeUndefined();
  });

  test('should return undefined if cache not enabled', () => {
    expect(getChannels.locally(channelIds)).toBeUndefined();
  });

  test('it should return cachedAt same date with oldest record', () => {
    enableCache();

    const cachedAt = Date.now();

    pushToCache(['channel', 'get', channelIds[0]], channel[0], { cachedAt });
    pushToCache(['channel', 'get', channelIds[1]], channel[1], { cachedAt: cachedAt + 1 });
    pushToCache(['channel', 'get', channelIds[2]], channel[2], { cachedAt: cachedAt + 2 });

    const data = getChannels.locally(channelIds);

    expect(data?.cachedAt).toEqual(cachedAt);

    disableCache();
  });
});

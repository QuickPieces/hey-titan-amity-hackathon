import { UNSYNCED_OBJECT_CACHED_AT_VALUE } from '~/utils/constants';
import { disableCache, enableCache, pullFromCache, pushToCache } from '~/cache/api';

import { client, generateRawMessage, pause } from '~/utils/tests';

import { convertFromRaw } from '../../utils';
import { onMessageCreated } from '../../events';
import { createMessage } from '../createMessage';

const rawMessageToCreate = generateRawMessage();
const messageToCreate = convertFromRaw(rawMessageToCreate);
const { messageId, uniqueId, ...messageWithoutId } = messageToCreate;

describe('createMessage', () => {
  const bundle = {
    data: messageToCreate.data,
    dataType: messageToCreate.dataType,
    referenceId: 'LOCAL_xxx',
    subChannelId: messageToCreate.subChannelId,
  };

  const response = {
    data: { messages: [rawMessageToCreate] },
  };

  beforeEach(enableCache);

  afterEach(disableCache);

  test('should return created message', async () => {
    client.http.post = jest.fn().mockResolvedValue(response);

    const { data: created } = await createMessage(bundle);

    expect(created).toMatchObject(messageToCreate);
    expect(created.uniqueId).toBeDefined();
  });

  test('should throw an error if request fails', async () => {
    client.http.post = jest.fn().mockRejectedValueOnce(new Error('error'));

    await expect(createMessage(messageWithoutId)).rejects.toThrow('error');
  });

  test('should put message into cache', async () => {
    client.http.post = jest.fn().mockResolvedValue(response);

    const { data: created } = await createMessage(bundle);

    const cache = pullFromCache(['message', 'get', created.messageId]);
    expect(cache).toMatchObject({ data: messageWithoutId });
  });

  test('should fire event `onMessageCreated`', async () => {
    let dispose;
    client.http.post = jest.fn().mockResolvedValueOnce(response);

    const callbackPromise = new Promise(resolve => {
      dispose = onMessageCreated(resolve);
    }).finally(dispose);

    await createMessage(messageWithoutId);

    await expect(callbackPromise).resolves.toMatchObject(messageWithoutId);
  });
});

describe('createMessage.optimistically', () => {
  beforeEach(enableCache);

  afterEach(disableCache);

  test('should create cache after created message', () => {
    const optimisticId = createMessage.optimistically(messageWithoutId)?.data?.messageId;
    const received = pullFromCache(['message', 'get', optimisticId])?.data;

    expect(received).toMatchObject(messageWithoutId);
  });

  describe('should increase message count after create message', () => {
    test('in sub channel', () => {
      const { channelId, subChannelId } = messageWithoutId;
      pushToCache(['channel', 'get', channelId], { channelId, messageCount: 2 });
      pushToCache(['subChannel', 'get', subChannelId], {
        channelId,
        subChannelId,
        messageCount: 2,
      });

      createMessage.optimistically(messageWithoutId);

      const cacheSubChannel = pullFromCache<Amity.SubChannel>([
        'subChannel',
        'get',
        subChannelId,
      ])?.data;

      expect(cacheSubChannel?.messageCount).toBe(3);
    });

    test('in channel if message created in main sub channel', () => {
      const { subChannelId } = messageWithoutId;
      pushToCache(['channel', 'get', subChannelId], { channelId: subChannelId, messageCount: 2 });
      pushToCache(['subChannel', 'get', subChannelId], {
        channelId: subChannelId,
        subChannelId,
        messageCount: 2,
      });

      createMessage.optimistically(messageWithoutId);

      const cacheChannel = pullFromCache<Amity.Channel>(['channel', 'get', subChannelId])?.data;
      expect(cacheChannel?.messageCount).toBe(3);
    });
  });

  test('should fire event `onMessageCreated`', async () => {
    let dispose;

    const callbackPromise = new Promise(resolve => {
      dispose = onMessageCreated(resolve);
    }).finally(dispose);

    createMessage.optimistically(messageWithoutId);

    await expect(callbackPromise).resolves.toMatchObject(messageWithoutId);
  });

  test('should define object as unsynced object', async () => {
    expect(createMessage.optimistically(messageWithoutId)?.cachedAt).toEqual(
      UNSYNCED_OBJECT_CACHED_AT_VALUE,
    );
  });
});

describe('uniqueId / referenceId', () => {
  const bundle = {
    data: messageToCreate.data,
    dataType: messageToCreate.dataType,
    subChannelId: messageToCreate.subChannelId,
  };

  beforeAll(enableCache);

  afterAll(disableCache);

  it('should optimistically create message with uniqueId', () => {
    const { data: message } = createMessage.optimistically(bundle)!;

    expect(message.uniqueId).toBeDefined();
    expect(message.uniqueId).toEqual(message.messageId);
  });

  it('should update messageId, retain uniqueId if optimistic message is in cache', async () => {
    const { data: optimisticMessage } = createMessage.optimistically(bundle)!;
    client.http.post = jest.fn().mockResolvedValue({
      data: { messages: [{ ...messageToCreate, referenceId: optimisticMessage.uniqueId }] },
    });

    const { data: message } = await createMessage(bundle);

    expect(client.http.post as jest.Mock).toHaveBeenCalledWith(
      expect.anything(),
      expect.objectContaining({ referenceId: optimisticMessage.uniqueId }),
    );
    expect(message.uniqueId).toEqual(optimisticMessage.uniqueId);
    expect(message.uniqueId).not.toEqual(message.messageId);
    expect(pullFromCache(['message', 'get', optimisticMessage.uniqueId])).toBeUndefined();
    expect(pullFromCache(['message', 'get', message.messageId])).toMatchObject({ data: message });
  });

  it('should set uniqueId to messageId if optimistic message is not in cache', async () => {
    const rawNewMessage = {
      ...rawMessageToCreate,
      messageId: 'new-message-id',
      referenceId: 'LOCAL_new-message-id',
    };
    const callback = jest.fn();

    onMessageCreated(callback);
    client.emitter.emit('message.created', {
      messages: [rawNewMessage],
      files: [],
      users: [],
    });
    await pause();

    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        messageId: rawNewMessage.messageId,
        uniqueId: rawNewMessage.messageId,
      }),
    );
  });
});

import { getActiveClient } from '~/client/api';
import { createEventSubscriber } from '~/core/events';

import { ingestInCache } from '~/cache/api/ingestInCache';
import { pullFromCache, pushToCache } from '~/cache/api';
import { hasMention } from '~/utils';
import { prepareMessagePayload } from '../utils';

/**
 * ```js
 * import { onMessageCreated } from '@amityco/ts-sdk'
 * const dispose = onMessageCreated(message => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.Message} has been created
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Message Events
 */
export const onMessageCreated = (callback: Amity.Listener<Amity.Message>): Amity.Unsubscriber => {
  const client = getActiveClient();

  const filter = (rawPayload: Amity.MessagePayload) => {
    const payload = prepareMessagePayload(rawPayload);
    const message = payload.messages[0];
    const cached = pullFromCache<Amity.Channel>(['channel', 'get', message.channelId]);

    if (cached && cached.data.defaultSubChannelId === message.subChannelId) {
      let update: Amity.Channel;

      // @ts-ignore
      if (cached.data.localReading) {
        update = {
          ...cached.data,
          localReadToSegment: message.channelSegment,
          localLastMentionSegment: hasMention(message, client.userId!)
            ? message.channelSegment
            : cached.data.localLastMentionSegment,
          messageCount: message.channelSegment,
          lastActivity: message.createdAt,
          updatedAt: message.createdAt,
        };
      } else {
        update = {
          ...cached.data,
          defaultSubChannelHasUnreadMention:
            hasMention(message, client.userId!) || cached.data.defaultSubChannelHasUnreadMention,
          defaultSubChannelUnreadCount: message.channelSegment - cached.data.localReadToSegment,
          lastActivity: message.createdAt,
          messageCount: message.channelSegment,
          updatedAt: message.createdAt,
        };
      }

      pushToCache(['channel', 'get', message.channelId], update);
      client.emitter.emit('local.channel.updated', { channels: [update] });
    }

    ingestInCache(payload);
    callback(message);
  };

  const disposers = [
    createEventSubscriber(client, 'message/onMessageCreated', 'message.created', filter),
    createEventSubscriber(client, 'local.message.created', 'local.message.created', payload =>
      callback(payload.messages[0]),
    ),
  ];

  return () => {
    disposers.forEach(fn => fn());
  };
};

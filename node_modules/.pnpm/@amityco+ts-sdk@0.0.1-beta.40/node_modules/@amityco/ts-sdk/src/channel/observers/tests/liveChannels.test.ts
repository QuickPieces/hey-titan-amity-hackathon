import { disableCache, enableCache } from '~/cache/api';
import {
  channel1,
  channel2,
  channelQueryResponse,
  channelQueryResponsePage2,
  channelRaw1,
  channelRaw2,
  client,
  connectClient,
  disconnectClient,
  generateRawChannel,
  generateRawMessage,
  mockPage,
  pause,
  rawChannelUser,
  rawChannelUser2,
  user11,
} from '~/utils/tests';
import { liveChannels } from '../liveChannels';
import { convertFromRaw, prepareChannelPayload } from '../../utils';

const getSnapshot = (params?: Record<string, any>) => {
  return {
    data: [] as Amity.Channel[],
    loading: true,
    error: undefined as any,
    ...params,
  };
};

const convertFromRawParams = {
  defaultSubChannelHasUnreadMention: false,
  defaultSubChannelUnreadCount: 0,
  localLastMentionSegment: 0,
  localReadToSegment: 0,
};

describe('liveChannels', () => {
  beforeAll(async () => {
    await connectClient();
  });

  afterAll(async () => {
    await disconnectClient();
  });

  beforeEach(enableCache);

  afterEach(disableCache);

  test('it should return channel collection', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(channelQueryResponse);

    liveChannels({}, callback);
    await pause();

    expect(callback).toHaveBeenCalledTimes(2);
    expect(callback).toHaveBeenNthCalledWith(1, expect.objectContaining(getSnapshot()));
    expect(callback).toHaveBeenNthCalledWith(
      2,
      expect.objectContaining(
        getSnapshot({
          data: prepareChannelPayload(channelQueryResponse.data).channels,
          loading: false,
        }),
      ),
    );
  });

  test('it should return data from cache', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue(channelQueryResponse);

    liveChannels({}, () => undefined);
    await pause();
    liveChannels({}, callback);
    await pause();

    expect(callback).toHaveBeenCalledTimes(2);
    expect(callback).toHaveBeenNthCalledWith(
      1,
      expect.objectContaining(
        getSnapshot({
          data: prepareChannelPayload(channelQueryResponse.data).channels,
        }),
      ),
    );
    expect(callback).toHaveBeenNthCalledWith(
      2,
      expect.objectContaining(
        getSnapshot({
          data: prepareChannelPayload(channelQueryResponse.data).channels,
          loading: false,
        }),
      ),
    );
  });

  const rawDeletedChannel = generateRawChannel({
    channelId: 'deleted-channel-id',
    isDeleted: true,
  });
  const deletedChannel = convertFromRaw(rawDeletedChannel, convertFromRawParams);
  const rawTaggedChannel = generateRawChannel({
    channelId: 'tagged-channel-id',
    tags: ['tag1', 'tag2'],
  });
  const taggedChannel = convertFromRaw(rawTaggedChannel, convertFromRawParams);
  const rawTaggedChannel2 = generateRawChannel({
    channelId: 'tagged-channel-id-2',
    tags: ['tag2'],
  });
  const taggedChannel2 = convertFromRaw(rawTaggedChannel2, convertFromRawParams);

  const filters: [string, Amity.ChannelLiveCollection, Amity.Channel[]][] = [
    ['deleted', { isDeleted: false }, [channel1, taggedChannel, taggedChannel2]],
    ['tagged', { tags: ['tag2'] }, [taggedChannel, taggedChannel2]],
    ['out excluded tags', { excludeTags: ['tag1'] }, [channel1, deletedChannel, taggedChannel2]],
    ['member', { membership: 'member' }, [channel1]],
    ['not member', { membership: 'notMember' }, [deletedChannel, taggedChannel, taggedChannel2]],
    [
      'all membership',
      { membership: 'all' },
      [channel1, deletedChannel, taggedChannel, taggedChannel2],
    ],
  ];

  test.each(filters)('it should filter by %s channels', async (filter, params, expected) => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        channels: [channelRaw1, rawDeletedChannel, rawTaggedChannel, rawTaggedChannel2],
        channelUsers: [rawChannelUser],
        files: [],
        users: [user11],
        ...mockPage,
      },
    });

    liveChannels(params, callback);

    expect(callback).toHaveBeenCalledTimes(1);
    // check if cache data returned (should be empty)
    expect(callback).toHaveBeenCalledWith(expect.objectContaining(getSnapshot()));

    await pause();

    expect(callback).toHaveBeenCalledTimes(2);
    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining(
        getSnapshot({
          loading: false,
          data: expected,
        }),
      ),
    );
  });

  test('it should return method to fetch next page', async () => {
    const callback = jest.fn();
    client.http.get = jest
      .fn()
      .mockResolvedValue(channelQueryResponse)
      .mockResolvedValueOnce(channelQueryResponsePage2);

    liveChannels({}, callback);
    await pause();

    expect(callback).toHaveBeenCalled();
    expect(callback.mock.lastCall).toHaveLength(1);

    const { onNextPage, hasNextPage } = callback.mock.lastCall[0];

    expect(hasNextPage).toBe(true);
    expect(onNextPage).toBeTruthy();

    onNextPage();
    await pause();

    // 4 -> because 1 local & server call each per call (2)
    expect(callback).toHaveBeenCalledTimes(4);
    expect(callback).toHaveBeenNthCalledWith(
      4,
      expect.objectContaining(
        getSnapshot({
          loading: false,
          data: [
            ...prepareChannelPayload(channelQueryResponsePage2.data).channels,
            ...prepareChannelPayload(channelQueryResponse.data).channels,
          ],
        }),
      ),
    );
  });

  describe('events', () => {
    const rawNewChannel = generateRawChannel({ channelId: 'new-channel-id' });

    const cases: [string, keyof Amity.Events, Amity.RawChannel, Amity.Channel[]][] = [
      [
        'it should add new channel to collection onCreate',
        'channel.created',
        rawNewChannel,
        [convertFromRaw(rawNewChannel, convertFromRawParams), channel1, channel2],
      ],
      [
        'it should add new channel to collection onJoin',
        'channel.joined',
        rawNewChannel,
        [convertFromRaw(rawNewChannel, convertFromRawParams), channel1, channel2],
      ],
      [
        'it should update channel in collection onUpdate',
        'channel.updated',
        channelRaw1,
        [channel1, channel2],
      ],
      [
        'it should update channel in collection onMuted',
        'channel.setMuted',
        { ...channelRaw1, isMuted: true },
        [{ ...channel1, isMuted: true }, channel2],
      ],
      [
        'it should remove channel from collection onDelete',
        'channel.deleted',
        { ...channelRaw1, isDeleted: true },
        [channel2],
      ],
      [
        'it should remove channel from collection onLeft',
        'channel.left',
        { ...channelRaw1, isDeleted: true },
        [channel2],
      ],
    ];

    test.each(cases)('%s', async (test, event, rawChannel, expected) => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue(channelQueryResponse);

      liveChannels({ isDeleted: false }, callback);
      await pause();
      client.emitter.emit(event, {
        channels: [rawChannel],
        channelUsers: [rawChannelUser],
        users: [],
        files: [],
      });
      await pause();

      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining(
          getSnapshot({
            data: expected,
            loading: false,
          }),
        ),
      );
    });

    it('should add the channel to collection if user is added to the channel and member filter is applied', async () => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue({
        data: {
          channels: [channelRaw2],
          channelUsers: [rawChannelUser2],
          files: [],
          users: [user11],
          ...mockPage,
        },
      });

      liveChannels({ membership: 'member' }, callback);
      await pause();
      client.emitter.emit('channel.membersAdded', {
        channels: [channelRaw1],
        channelUsers: [rawChannelUser],
        users: [user11],
        files: [],
      });
      await pause();

      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining(getSnapshot({ data: [channel1, channel2], loading: false })),
      );
    });

    it('should add the channel to collection if user is removed from the channel and nonMember filter is applied', async () => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue({
        data: {
          channels: [channelRaw2],
          channelUsers: [],
          files: [],
          users: [user11],
          ...mockPage,
        },
      });

      liveChannels({ membership: 'notMember' }, callback);
      await pause();
      client.emitter.emit('channel.membersRemoved', {
        channels: [channelRaw1],
        channelUsers: [{ ...rawChannelUser, membership: 'none' }],
        users: [user11],
        files: [],
      });
      await pause();

      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining(getSnapshot({ data: [channel1, channel2], loading: false })),
      );
    });

    it('should add the channel to collection if tag is added to the channel and tags is applied', async () => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue({
        data: {
          channels: [channelRaw2],
          channelUsers: [rawChannelUser2],
          files: [],
          users: [user11],
          ...mockPage,
        },
      });

      liveChannels({ tags: ['tag1'] }, callback);
      await pause();
      client.emitter.emit('channel.updated', {
        channels: [{ ...channelRaw1, tags: ['tag1'] }],
        channelUsers: [rawChannelUser],
        users: [user11],
        files: [],
      });
      await pause();

      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining(
          getSnapshot({ data: [{ ...channel1, tags: ['tag1'] }, channel2], loading: false }),
        ),
      );
    });

    test.each([
      [
        'should remove the channel from the collection if user is removed from the channel and member filter is applied',
        'channel.membersRemoved',
      ],
      [
        'should remove the channel from the collection if user is left from the channel and member filter is applied',
        'channel.left',
      ],
    ] as [string, keyof Amity.Events][])('%s', async (test, event) => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue({
        data: {
          channels: [channelRaw1, channelRaw2],
          channelUsers: [rawChannelUser, rawChannelUser2],
          files: [],
          users: [user11],
          ...mockPage,
        },
      });

      liveChannels({ membership: 'member' }, callback);
      await pause();
      client.emitter.emit(event, {
        channels: [channelRaw1],
        channelUsers: [{ ...rawChannelUser, membership: 'none' }],
        users: [user11],
        files: [],
      });
      await pause();

      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining(getSnapshot({ data: [channel2], loading: false })),
      );
    });

    test.each([
      [
        'should remove the channel from the collection if user is added to the channel and notMember filter is applied',
        'channel.membersAdded',
      ],
      [
        'should remove the channel from the collection if user is joined to the channel and notMember filter is applied',
        'channel.joined',
      ],
    ] as [string, keyof Amity.Events][])('%s', async (test, event) => {
      const callback = jest.fn();
      client.http.get = jest.fn().mockResolvedValue({
        data: {
          channels: [channelRaw1, channelRaw2],
          channelUsers: [],
          files: [],
          users: [user11],
          ...mockPage,
        },
      });

      liveChannels({ membership: 'notMember' }, callback);
      await pause();
      client.emitter.emit('channel.membersAdded', {
        channels: [channelRaw1],
        channelUsers: [rawChannelUser],
        users: [user11],
        files: [],
      });
      await pause();

      expect(callback).toHaveBeenNthCalledWith(
        3,
        expect.objectContaining(getSnapshot({ data: [channel2], loading: false })),
      );
    });
  });

  it('should increase the unread count once message is created', async () => {
    const callback = jest.fn();
    client.http.get = jest.fn().mockResolvedValue({
      data: {
        channels: [channelRaw1],
        channelUsers: [rawChannelUser],
        files: [],
        users: [user11],
        ...mockPage,
      },
    });

    liveChannels({}, callback);
    await pause();
    client.emitter.emit('message.created', {
      messages: [
        generateRawMessage({
          channelPublicId: channelRaw1.channelId,
          messageFeedId: channelRaw1._id,
          segment: channelRaw1.messageCount + 1,
        }),
      ],
      files: [],
      users: [],
    });
    await pause(500);

    expect(callback).toHaveBeenNthCalledWith(
      3,
      expect.objectContaining(
        getSnapshot({
          data: [
            {
              ...channel1,
              defaultSubChannelUnreadCount: 1,
              lastActivity: expect.anything(),
              messageCount: channel1.messageCount + 1,
              updatedAt: expect.anything(),
            },
          ],
          loading: false,
        }),
      ),
    );
  });
});

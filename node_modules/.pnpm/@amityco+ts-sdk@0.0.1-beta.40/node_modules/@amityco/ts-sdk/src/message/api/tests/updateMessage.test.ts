import { disableCache, enableCache, pullFromCache, pushToCache } from '~/cache/api';
import { client, generateRawMessage } from '~/utils/tests';

import { updateMessage } from '../updateMessage';
import { onMessageUpdated } from '../../events';
import { convertFromRaw } from '../../utils';

const rawMessageToUpdate = generateRawMessage();
const messageToUpdate = convertFromRaw(rawMessageToUpdate);
const { messageId } = messageToUpdate;
const patch = { data: { text: 'hello world' } };
const rawUpdatedMessage = { ...rawMessageToUpdate, ...patch };
const updatedMessage = convertFromRaw(rawUpdatedMessage);

const getResolvedMessageValue = () => ({
  data: {
    messages: [rawUpdatedMessage],
    users: [],
    files: [],
  },
});

describe('updateMessage', () => {
  test('should return updated message', async () => {
    client.http.put = jest.fn().mockResolvedValueOnce(getResolvedMessageValue());

    const recieved = updateMessage(messageId, patch);

    await expect(recieved).resolves.toEqual(expect.objectContaining({ data: updatedMessage }));
  });

  test('should throw an error if request fails', async () => {
    client.http.put = jest.fn().mockRejectedValueOnce(new Error('error'));

    await expect(updateMessage(messageId, patch)).rejects.toThrow('error');
  });

  test('should update cache after updated messages', async () => {
    enableCache();
    client.http.put = jest.fn().mockResolvedValueOnce(getResolvedMessageValue());

    await updateMessage(messageId, patch);
    const recieved = pullFromCache<Amity.Message>(['message', 'get', messageId])?.data;

    expect(recieved).toEqual(expect.objectContaining(patch));

    disableCache();
  });

  test('should fire event `onMessageUpdated`', async () => {
    let dispose;
    client.http.put = jest.fn().mockResolvedValueOnce(getResolvedMessageValue());

    const callbackPromise = new Promise(resolve => {
      dispose = onMessageUpdated(resolve);
    }).finally(dispose);

    await updateMessage(messageId, patch);

    await expect(callbackPromise).resolves.toEqual(expect.objectContaining(updatedMessage));
  });
});

describe('updateMessage.optimistically', () => {
  beforeEach(() => enableCache());
  afterEach(() => disableCache());

  test('should update cache after updated message', () => {
    pushToCache(['message', 'get', messageId], messageToUpdate);

    updateMessage.optimistically(messageId, patch);
    const recieved = pullFromCache<Amity.Message>(['message', 'get', messageId])?.data;

    expect(recieved).toEqual(expect.objectContaining(patch));
  });

  test('should fire event `onMessageUpdated`', async () => {
    let dispose;

    const callbackPromise = new Promise(resolve => {
      dispose = onMessageUpdated(data => {
        resolve(data);
      });
    }).finally(dispose);

    updateMessage.optimistically(messageId, patch);

    await expect(callbackPromise).resolves.toEqual(
      expect.objectContaining({
        ...updatedMessage,
        updatedAt: expect.anything(),
      }),
    );
  });

  test('should define object as unsynced object', () => {
    pushToCache(['message', 'get', messageId], messageToUpdate);

    expect(updateMessage.optimistically(messageId, patch)?.cachedAt).toBe(-1);
  });
});

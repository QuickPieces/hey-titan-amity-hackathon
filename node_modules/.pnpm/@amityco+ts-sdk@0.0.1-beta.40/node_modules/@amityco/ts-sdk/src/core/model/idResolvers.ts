/**
 * Manually computed type which links each key with a function
 * used to return the object's unique id. The type is computed
 * to avoid using any and give some typing security at the
 * resolver's level.
 */
type Resolver<T extends Amity.Domain> = (model: Amity.Minimal[T]) => string;
type Resolvers<T extends Amity.Domain = Amity.Domain> = {
  [K in T]: Resolver<K>;
};

/** @hidden */
const idResolvers: Resolvers = {
  user: ({ userId }) => userId,
  file: ({ fileId }) => fileId,
  role: ({ roleId }) => roleId,

  channel: ({ channelId }) => channelId,
  subChannel: ({ subChannelId }) => subChannelId,
  channelUsers: ({ channelId, userId }) => `${channelId}#${userId}`,
  message: ({ messageId }) => messageId,

  community: ({ communityId }) => communityId,
  category: ({ categoryId }) => categoryId,
  communityUsers: ({ communityId, userId }) => `${communityId}#${userId}`,
  post: ({ postId }) => postId,
  comment: ({ commentId }) => commentId,
  poll: ({ pollId }) => pollId,
  reaction: ({ reactionId }) => reactionId,

  stream: ({ streamId }) => streamId,

  follow: ({ from, to }) => `${from}#${to}`,
  followCount: ({ userId }) => userId,

  feed: ({ targetId, feedId }) => `${targetId}#${feedId}`,
};

/**
 * Retrieve the id resolver matching a domain name
 *
 * @param name the domain name for the resolve
 * @returns an idResolver function for the given domain name
 */
export const getResolver = <T extends Amity.Domain>(name: T): Resolver<T> => idResolvers[name];

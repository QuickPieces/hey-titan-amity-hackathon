import { getResolver } from '~/core/model';

import { disableCache, enableCache, pushToCache } from '~/cache/api';
import { ingestInCache } from '~/cache/api/ingestInCache';

import { prepareChannelPayload } from '~/channel/utils';
import {
  client,
  channelQueryResponse,
  channelTagQueryResponse,
  channelExcludeTagQueryResponse,
} from '~/utils/tests';

import { queryChannels } from '../queryChannels';

describe('queryChannels', () => {
  // integration_test_id: 06c14dab-4799-4f26-9e52-be7c12b3bdb3
  test('it should return channels', async () => {
    const expected = prepareChannelPayload(channelQueryResponse.data).channels;
    client.http.get = jest.fn().mockResolvedValue(channelQueryResponse);

    const { data } = await queryChannels();

    expect(data).toEqual(expected);
  });

  // integration_test_id: 253fb0ac-f868-4570-9b1e-98b08861aa53
  test('it should return channels match with membership type', async () => {
    // Actually there is no any flag to tell about this list is relate to membership type
    // But need to implement this case to match with our test list
    const expected = prepareChannelPayload(channelQueryResponse.data).channels;
    client.http.get = jest.fn().mockResolvedValue(channelQueryResponse);
    const { data } = await queryChannels({ membership: 'member' });
    expect(data).toEqual(expected);
  });

  // integration_test_id: 92329d41-9403-44e7-979f-ed227e6ab120
  test('it should return channels match with tags query type', async () => {
    const expected = prepareChannelPayload(channelTagQueryResponse.data).channels;
    client.http.get = jest.fn().mockResolvedValue(channelTagQueryResponse);
    const { data } = await queryChannels({ tags: ['tag1'] });
    expect(data).toEqual(expected);
    expect(data[0].tags).toContain('tag1');
  });

  // integration_test_id: 5249778c-6d99-4e2f-9b80-2f4ea6ae1833
  test('it should return channels without tags which defined in exclude options', async () => {
    const expected = prepareChannelPayload(channelExcludeTagQueryResponse.data).channels;
    client.http.get = jest.fn().mockResolvedValue(channelExcludeTagQueryResponse);
    const { data } = await queryChannels({ excludeTags: ['tag1'] });
    expect(data).toEqual(expected);

    data.forEach(item => {
      expect(item.tags).not.toContain('tag1');
    });
  });

  test('it should throw error', async () => {
    client.http.get = jest.fn().mockRejectedValueOnce(new Error('error'));

    await expect(queryChannels()).rejects.toThrow('error');
  });

  test('it should update cache upon fetching data from server', async () => {
    enableCache();
    client.http.get = jest.fn().mockResolvedValue(channelQueryResponse);

    const { data: got } = await queryChannels();
    const { data } = queryChannels.locally()!;

    expect(data).toBeDefined();
    expect(got).toEqual(data);

    disableCache();
  });
});

describe('queryChannels.locally', () => {
  const cacheKey = ['channel', 'query', { options: { limit: 10, after: undefined } }];

  test('it should fetch query locally if present in cache', () => {
    enableCache();

    const { paging, ...payload } = channelQueryResponse.data;
    const data = prepareChannelPayload(payload);
    const { channels } = data;

    ingestInCache(data);

    pushToCache(cacheKey, { channels: channels.map(getResolver('channel')), paging });

    const { data: got } = queryChannels.locally()!;

    expect(got).toBeDefined();
    expect(got).toEqual(channels);

    disableCache();
  });

  test('it should return undefined if only partial data in cache', () => {
    enableCache();

    const { paging, ...payload } = channelQueryResponse.data;
    const data = prepareChannelPayload(payload);
    const { channels } = data;

    // ingest incomplete data
    ingestInCache({
      ...data,
      channels: [data.channels[0]],
    });

    pushToCache(cacheKey, {
      channels: channels.map(getResolver('channel')),
      paging,
    });

    const got = queryChannels.locally()!;

    expect(got).toBeUndefined();

    disableCache();
  });

  test('it should return undefined if params do not match', () => {
    enableCache();

    const { data } = channelQueryResponse;
    const { paging, ...payload } = data;
    const { channels: expected } = prepareChannelPayload(payload);

    ingestInCache(prepareChannelPayload(data));

    pushToCache(cacheKey, { channels: payload.channels.map(getResolver('channel')), paging });

    const { data: received } = queryChannels.locally()!;
    const received2 = queryChannels.locally({ displayName: 'test' })!;

    expect(received).toBeDefined();
    expect(received).toEqual(expected);
    expect(received2).toBeUndefined();

    disableCache();
  });

  test('it should return undefined if data not in cache', () => {
    enableCache();

    const got = queryChannels.locally();

    expect(got).toBeUndefined();

    disableCache();
  });

  test('it should return undefined if cache disabled', () => {
    expect(queryChannels.locally()).toBeUndefined();
  });
});
